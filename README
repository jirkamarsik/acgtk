**************************************************************************
*                                                                        *
*                 ACG development toolkit                                *
*                                                                        *
*                  Copyright 2008 INRIA                                  *
*                                                                        *
*  More information on "http://acg.gforge.inria.fr/"                     *
*  License: CeCILL, see the LICENSE file or "http://www.cecill.info"     *
*  Authors: see the AUTHORS file                                         *
*                                                                        *
*                                                                        *
*                                                                        *
*                                                                        *
*  $Rev::                              $:  Revision of last commit       *
*  $Author::                           $:  Author of last commit         *
*  $Date::                             $:  Date of last commit           *
*                                                                        *
**************************************************************************

This distribution provides two executables (possibly with the .opt
extension, see the INSTALL file):

	acgc
and
	acg


************
*** acgc ***
************

acgc is a "compiler" of ACG source code, i.e. files containing
definitions of signarures and lexicons. It basically checks whether
they are correctly written (syntactically and wrt types and constant
typing). An interactive mode is available to parse terms according to
signatures.

Run

	./acgc -help

to get help

***********
*** acg ***
***********

acg is an interpreter of command meant to be useful when using
ACGs. To get a list of command, run

	./acg

then on the prompt type

	help;




Example files are given in the ./examples directory. Read the
./examples/README file

********************
** ACG emacs mode **
********************

There is an ACG emacs mode (acg.el) in the emacs directory.

Look at the INSTALL file to see how to install it.

It's main feature is to be loaded when editing an acg data file (with
signatures and lexicons). It is automatically loaded for files with a
.acg extension

It basically contains compilation directives and next-error
searching.

1. First load an acg file

2. then run "M-x compile" (or C-cC-c) to call the compiler (acgc or
acgc.opt)

3. then run "M-x next-error" (or C-x`) to search for the next error
(if any) and highlights it



************************************
* Syntax of signature and lexicons *
************************************

(see the examples/tag.acg file for an example)

Signatures are defined by:

signature my_sig_name=
	sig_entries
end

Sig_entries always ends with a ; and can be:
+ type declaration as in
	NP,S : type;

+ type definition as in
	o :type;
	string = o -> o;

Note that type constructors are -> and => for the linear and
intuitionnistic arrow respectively.

+ constant declarations as in
	foo:NP;
	bar,dummy:NP -> S;
	infix + : string -> string -> string;
	prefix - : bool -> bool;
	binder All : (e =>t) -> t;
	infix > : bool -> bool -> bool; (*This means implication*)

Note that infix and prefix are keywords to introduce symbols (of
length 1. This probably will change).
Also notes that comments are surrounded by (* and *)

+ constant definitions as in
	n = lambda n. bar n : NP -> S;
	infix + = lambda x y z.x(y z): string -> string -> string;
	prefix - = lambda p.not p:bool -> bool;
	everyone = lambda P. All x. (human x) > (P x) ;

Note the syntax for binders (All in the last example). Available
construction for terms are:
	lambda x y z.t 
for linear abstraction

	Lambda x y z.t
for non-linear abstraction

	t u v
for application (eauql to (t u) v)

	t SYM u
if SYM is a infix symbol (lowest priority)

	SYM t
if SYM is a prefic symbol (highest priority)

	BINDER x y z.t
if BINDER is a binder

Lexicons are defined by:

lexicon my_lex_name(abstract_sig_name) : object_sig_name =
	lex_entries
end

Lex_entries always ends with a ; and have the following form:
	abstract_atomic_type1, abstract_atomic_type2 := object_type;
	abstract_const1, abstract_const2 := object_term;
