%mltop{
(*  open Abstract_syntax*)
    open Script_lexer
    
(*  type token = Script_lexer.token *)
      
  let id = fun x -> x

  let pr s = Printf.printf "%s\n%!" s
    
  module Make (E:Environment.Environment_sig) =
  struct  
    
    (*    module Data_parser = Parser.Make(E)*)
    module F = Functions.Make(E)

    let echo s = Printf.printf "%s\n%!" s


  }
  
  {
    open Dyp
    let local_data = (E.empty,fun _ -> failwith "Bug: Not yet defined")
    let global_data = false

  }
  
  
%token
EOII
<(string*Abstract_syntax.Abstract_syntax.location*string)>LOAD_DATA
<(string*Abstract_syntax.Abstract_syntax.location*string)>LOAD_SCRIPT
LOAD_HELP
LIST
SELECT
UNSELECT
TRACE
HELP
<Abstract_syntax.Abstract_syntax.location>PRINT
<(string*Abstract_syntax.Abstract_syntax.location*string)>ANALYSE
<(string*Abstract_syntax.Abstract_syntax.location*string)>ADD
COMPOSE
<string>SEMICOLONN
AS
DONT
WAIT
<(string*Abstract_syntax.Abstract_syntax.location)>IDENTT
CREATE_SIG
CREATE_LEX
CREATE_HELP
<(string*Abstract_syntax.Abstract_syntax.location*string)>SAVE


%start <(E.t)> zzcommands

/*%local_data_type <(E.t * (string -> E.t -> E.t))>
%global_data_type <bool>*/

%%

  zzcommands :
| EOII @{let e,f = dyp.last_local_data in
	 let () = Printf.printf "End of parsing, getting:\n%!" in 
	 let () = F.list e in 
	   (e,[Local_data (e,f)])}
| command[c] ...@{let e,f = (dyp.last_local_data) in
		  let e' = 
		    try
		      c e
		    with
		      | F.Not_yet_implemented s-> raise (Scripting_errors.Error (Scripting_errors.Not_yet_implemented s,(Lexing.dummy_pos,Lexing.dummy_pos))) in
		  let () = if dyp.global_data then ignore(read_line()) else () in
		    e',[Local_data (e',f)]}
      zzcommands {fst dyp.last_local_data}


      command:
| WAIT SEMICOLONN[l] @{(fun e -> let () = echo l in let () = F.wait () in e),[Global_data true]}
| DONT WAIT SEMICOLONN[l] @{(fun e ->  let () = echo l in let () = F.dont_wait () in e),[Global_data false]}
| LOAD_DATA[(s,loc,l)]  {fun e ->  let () = echo l in  F.load F.Data  s e}
| LOAD_SCRIPT[(s,loc,l)]  {fun e ->  let () = echo l in
			   let new_env = F.load (F.Script (snd dyp.last_local_data)) s e in
			   let () = Printf.printf "load script performed, getting:\n%!" in
			   let () = F.list new_env in
			     new_env}
| LIST SEMICOLONN[l] {fun e ->  let () = echo l in let () = F.list e in e}
| SELECT IDENTT[(name,loc)]  SEMICOLONN[l] {fun e ->  let () = echo l in F.select name loc e}
| UNSELECT SEMICOLONN[l] { let () = echo l in F.unselect}
| TRACE SEMICOLONN[l] { let () = echo l in fun e -> let () = F.trace () in e}
| DONT TRACE SEMICOLONN[l] { let () = echo l in fun e -> let () = F.dont_trace () in e}
| optional_ident[name] PRINT[p] SEMICOLONN[l] { let () = echo l in fun e -> 
					   let loc = 
					     match name with
					       | None -> p
					       | Some (_,l) -> l in
					       match name with
						 | None -> let () = F.print e loc in e
						 | Some (n,l) -> let () = F.print ~name:n e loc in e}
| optional_idents[names] ANALYSE[(t,l,line)]   { let () = echo line in fun e -> 
					     match names with
					       | [] -> let () = F.analyse e t l in e
					       | _ -> let () = F.analyse  ~names e t l in e}
| optional_idents[names] ADD[(t,l,line)]   { let () = echo line in fun e -> 
					     match names with
					       | [] -> F.add e t l
					       | _ -> F.add  ~names e t l}
| COMPOSE IDENTT[n1] IDENTT [n2] AS IDENTT[n3] SEMICOLONN[l] { let () = echo l in fun e -> F.compose n1 n2 n3 e}
| HELP SEMICOLONN[l] {let () = echo l in fun e -> let () = F.help (F.Help None) in e}
| all_commands[c] HELP SEMICOLONN[l] {let () = echo l in fun e -> let () = F.help (F.Help (Some c)) in e}
| LOAD_HELP SEMICOLONN[l] {let () = echo l in fun e -> let () = F.help (F.Help (Some F.Load)) in e}
| CREATE_SIG IDENTT[n] SEMICOLONN[l] {let () = echo l in fun e -> F.create_sig n e}
| CREATE_LEX IDENTT[n] IDENTT[n1] IDENTT[n2]  SEMICOLONN[l] {let () = echo l in fun e -> F.create_lex ~abs:n1 ~obj:n2 n e}
| optional_idents[names] SAVE[(filename,l,line)]   { let () = echo line in fun e -> 
						match names with
						  | [] -> let () = F.save filename e l in e
						  | _ -> let () = F.save ~names filename e l in e}

      all_commands:
| WAIT {F.Wait}
| DONT WAIT {F.Dont_wait}
| LIST {F.List}
| SELECT {F.Select}
| UNSELECT {F.Unselect}
| TRACE {F.Trace}
| DONT TRACE {F.Dont_trace}
| PRINT {F.Print}
| ANALYSE {F.Analyse}
| ADD {F.Add}
| COMPOSE {F.Compose}
| HELP {F.Help None}


      optional_ident :
| {None}
| IDENTT[id] {Some id}


      optional_idents :
| {[]}
| IDENTT[id] optional_idents[ids] {id::ids}

%%

{

  let rec parse_file  filename env =
    let in_ch = try open_in filename with | Sys_error s -> raise (Error.Error (Error.System_error s)) in
    let lexbuf = Lexing.from_channel in_ch in
    let () = Printf.printf "Parsing script file \"%s\"...\n%!" filename in
      try
	let new_env=
	  try (fst (List.hd (zzcommands ~global_data:(F.should_wait ()) ~local_data:(env,parse_file)  Script_lexer.lexer lexbuf))) with
	    |  Dyp.Syntax_error -> raise (Error.dyp_error lexbuf filename) in
	let () = Printf.printf "Done.\n%!" in
	let () = Printf.printf "I parsed the script file and now:\n%!" in
	let () = F.list new_env in
	  new_env
      with
	| Error.Error e -> 
	    let () = Printf.fprintf stderr "Error: %s\n%!" (Error.error_msg e filename) in
	    let _ = Script_lexer.reset_echo () in
	      env

  let commented_regexp = Str.regexp "^[ \t#]*#"

  let is_fully_commented_line s = Str.string_match commented_regexp s 0

  let bufferize () =
    let () = Printf.printf "# " in
    let buf = Buffer.create 16 in
    let no_semi_colon=ref true in
    let () =
      while !no_semi_colon do
	let input = read_line () in
	  if not (is_fully_commented_line input) then
	    try
	      let semi_colon_index=String.index input ';' in
	      let () = Buffer.add_string buf (String.sub input 0 (semi_colon_index+1)) in
		no_semi_colon:=false
	    with
	      | Not_found ->
		  Buffer.add_string buf input ;
		  Buffer.add_char buf '\n';
		  Printf.printf "  "
	  else
	    ()
      done in
      Buffer.contents buf
	

	
  let parse_entry env =
    let in_str = bufferize () in
    let lexbuf = Lexing.from_string in_str in
    let new_env=
      try
	try (fst (List.hd (zzcommands ~global_data:false ~local_data:(env,parse_file)  Script_lexer.lexer lexbuf))) with
	  |  Dyp.Syntax_error -> raise (Error.dyp_error lexbuf "stdin")
      with
	| Failure "lexing: empty token" -> env
	| Error.Error e -> 
	    let () = Printf.fprintf stderr "Error: %s\n%!" (Error.error_msg e "stdin") in
	    let _ = Script_lexer.reset_echo () in
	      env
	| Scripting_errors.Error (e,p) ->
	    let () = Printf.fprintf stderr "Error: %s\n%!" (Scripting_errors.error_msg e p) in
	    let _ = Script_lexer.reset_echo () in
	      env in
      new_env
	

end}

%mlitop{
(*  open Abstract_syntax*)
  open Script_lexer

  module Make(E:Environment.Environment_sig) : 
  sig


    module F : Functions.Action_sig with type env=E.t

(*    type token = Script_lexer.token*)

    val parse_file : string -> E.t -> E.t

    val parse_entry : E.t -> E.t
  }

%mli{end}
