open PersistentArray
open Focused_list
open Datalog_AbstractSyntax


module ASPred=AbstractSyntax.Predicate
module ASRule=AbstractSyntax.Rule
module ASProg=AbstractSyntax.Program
  
module Make (S:UnionFind.Store) =
struct
  exception Fails
  module UF= UnionFind.Make(S)

  module Predicate =
  struct
    
    (** For the type of the predicates, we use the same identifiers as
	for the predicates of the datalog abstract syntax {!
	Datalog_AbstractSyntax.AbstractSyntax.Predicate} *)
    type predicate={p_id:ASPred.pred_id;
		    arity:int;
		   }
      
    (** [make_predicate p] returns an actual predicate from some
	abstract syntax representation {!
	Datalog_AbstractSyntax.AbstractSyntax.Predicate} *)
    let make_predicate p = {p_id=p.ASPred.p_id;arity=p.ASPred.arity}
      
    (** [to_abstract p (s,content) (vars,vargen)] returns a triple
	[(abs_p,vars',vargen')] where [abs_p] is the [p] predicate
	translated into an equivalent predicate from the datalog
	abstract syntax. In order to be able to perform this
	translation, we need [s] and index and [content] a indexed
	storage data structure which is meant to contain the arguments
	of [p] starting at index [s]. Then, in case some variable are
	still present, to be able to translate them according to the
	other variables that could be in the content [content], we
	need to check in [vars] if it's index already was associated
	to some [VarGen.id] generated by [vargen]. In this case
	[vars'=vars] and [vargen'=vargen], otherwise [vars'] is [var]
	with a new variable generated by [vargen] associated to the
	variable index, and [vargen'] is the result of generating this
	new variable from [vargen].*)
    let to_abstract {p_id=id;arity=arity} (start,content) (vars,vargen) pred_table =
      LOG "Starting the extraction of predicate %s/%d" (ASPred.to_string {ASPred.p_id=id;ASPred.arity=arity;ASPred.arguments=[]} pred_table ConstGen.Table.empty) arity LEVEL TRACE;
      let get_var i (vars,vargen) = 
	try
	  Utils.IntMap.find i vars,(vars,vargen)
	with
	| Not_found -> 
	  let new_var,new_vargen = VarGen.get_fresh_id vargen in
	  new_var,(Utils.IntMap.add i new_var vars,new_vargen) in
      let new_vars,new_vargen,rev_arguments=
	List.fold_left
	  (fun (vars,vargen,acc) -> function
	  | UF.Value v -> vars,vargen,((ASPred.Const v)::acc)
	  | UF.Link_to i -> let var,(new_vars,new_vargen)=get_var i (vars,vargen) in
			    new_vars,new_vargen,(ASPred.Var var)::acc)
	  (vars,vargen,[])
	  (UF.extract ~start:start arity content) in      
      {ASPred.p_id=id;
       ASPred.arity=arity;
       arguments=List.rev rev_arguments},
      new_vars,
      new_vargen
	
    (** [lst_to_abstract lst (start,content) (vars,vargen)] returns a
	4-uple [(abs_p_lst,start',vars',vargen')] where all the
	predicates of [lst] have been translated and put into
	[abs_p_lst]. The predicates in [lst] are supposed to be
	represented in [content] starting at index [start] in an
	adjacent way. [start'] indexes the component of the next
	predicate in [content], and [vars'] and [vargen'] keep track
	of the variable that can have been generated. *)
    let lst_to_abstract lst (start,content) (vars,vargen) pred_table =
      let next_idx,vars',vargen',abs_preds =
	List.fold_left
	  (fun (s,l_vars,l_vargen,acc) p ->
	    let abs_p,new_vars,new_vargen = to_abstract p (s,content) (l_vars,l_vargen) pred_table in
	    s+p.arity,new_vars,new_vargen,abs_p::acc)
	  (start,vars,vargen,[])
	  lst in
      (List.rev abs_preds),next_idx,vars',vargen'
	
	
    (** [instantiate_with p (i,c)] instantiates the content [c] with the
	fact [p] starting at [i]. It returns a pair [(i',c')] when [i]
	is the index of the first component of the [p] predicate in the
	content [c] {e THIS IS NOT CHECKED HERE}. [i'=i+a] where [a] is
	the arity of [p] (it means [i'] should index the first component
	of the next predicate in the content of the rule) and [c'] is a
	new content where all the components between [i] and [i'-1] have
	been instantiated with the components of [p]. When such an
	instantiation fails, it raises {! UF.Union_Failure} *)
    let instantiate_with
	{ASPred.p_id=_;ASPred.arity=_;ASPred.arguments=args}
	(idx,content) =
      let last_i,(new_c,_) =
	List.fold_left
	  (fun  (i,(cont,vars)) value ->
	    (i+1,
	     match value with
	     | ASPred.Const v -> UF.instantiate i v cont,vars
	     | ASPred.Var var -> 
	       try
		 UF.union i (VarGen.IdMap.find var vars) cont,vars
	       with
	       | Not_found -> cont,VarGen.IdMap.add var i vars)
		 
	    (*		 failwith "Bug: Trying to instantiate with a non-closed predicate" *)
	  )
	  (idx,(content,VarGen.IdMap.empty))
	  args in
      last_i,new_c
	
	
	
    (** A map whose key is of type of the predicates identifers *)
    module PredMap=ASPred.PredIdMap


      
      
    (* TODO : This should be a map recording the way each of this
       predicate was derived *)
      
    (** A map whose key is of type [predicate] *)
    (* TODO: Could it be replaced by predicate id only? *)
    module FactSet=Set.Make
      (struct
	type t=ASPred.predicate
	let compare = ASPred.compare 
       end)


    let add_facts_to_buffer b pred_table cst_table f =
      FactSet.iter (fun elt -> Buffer.add_string b (Printf.sprintf "%s.\n" (ASPred.to_string elt pred_table cst_table))) f 

    let add_map_to_facts_to_buffer b pred_table cst_table map =
      PredMap.iter
	(fun _ v -> add_facts_to_buffer b pred_table cst_table v)
	map


    let facts_to_string facts pred_table cst_table =
      let buff=Buffer.create 100 in
      let () = add_map_to_facts_to_buffer buff pred_table cst_table facts in 
      Buffer.contents buff
      
    (** [conditionnal_add e s1 s2 s3] adds [e] to the set [s1] only if
	[e] doesn't belong to [s2] nor to [s3]*)
    let conditionnal_add e s1 s2 s3=
      if FactSet.mem e s2 then
	s1
      else
	if FactSet.mem e s3 then
	  s1
	else
	  FactSet.add e s1
	    
    (** A map indexed by integers to store facts at step (or time) [i]
	in the seminaive algorithm. These facts are also indexed by
	[predicate_id_type]. *)
    module Indexed_Facts=Utils.IntMap 


    module Premise =
    struct
      type t = ASPred.predicate list
      let rec compare pred_lst_1 pred_lst_2 =
	match pred_lst_1,pred_lst_2 with
	| [],[] -> 0
	| _,[] -> 1
	| [],_ -> -1
	| p1::tl1,p2::tl2 ->
	  let diff =ASPred.compare p1 p2 in
	  if diff <> 0 then
	    diff
	  else
	    compare tl1 tl2

      let to_string premises pred_table const_table =
	Utils.string_of_list "," (fun p -> ASPred.to_string p pred_table const_table) premises


    end

    module PremiseSet=Set.Make(Premise)

    module PredicateMap=Map.Make(
      struct 
	type t = ASPred.predicate
	let compare = ASPred.compare
      end)




    let rec format_derivations2 pred_table cst_table map =
      PredicateMap.iter
	(fun k v -> let () = format_derivation "" k v pred_table cst_table map FactSet.empty in 
		    Printf.fprintf stdout "\n")
	map
    and format_derivation prefix k v pred_table cst_table map set=
      if FactSet.mem k set then
	Printf.printf "... (infinite loop on %s)" (ASPred.to_string k pred_table cst_table) 
      else
	let new_set=FactSet.add k set in
	let _ = 
	  PremiseSet.fold
	    (fun premises (first,length)  -> 
	      let new_length,new_prefix= 
		match first with
		| true ->
		  let s=ASPred.to_string k pred_table cst_table in
		  let () = Printf.fprintf stdout "%s" s in
		  let n_l=String.length s in
		  n_l,Printf.sprintf "%s%s" prefix (String.make n_l ' ')
		| false ->  
		  let () = Printf.fprintf stdout "\n%s  %s" prefix (String.make (length -2) '>') in
		  length,Printf.sprintf "%s  %s" prefix (String.make (length-2) ' ') in
	      let () = format_premises2 new_prefix (List.rev premises) true pred_table cst_table map new_set in
	      (*	  let () = Printf.fprintf stdout "\n" in*)
	      false,new_length)
	    v
	    (true,0) in
	()
    and format_premises2 prefix premises first pred_table cst_table map set =
      let () = match first with
	| true -> Printf.fprintf stdout ":--" 
	| false -> Printf.fprintf stdout "\n%s|--" prefix in
      match premises with
      | [] -> ()
      | [p] -> 
	let () = 
	  try
	    format_derivation (Printf.sprintf "%s   " prefix) p (PredicateMap.find p map) pred_table cst_table map set
	  with
	  | Not_found -> Printf.fprintf stdout "%s" (ASPred.to_string p pred_table cst_table)   in
	Printf.fprintf stdout ""
      | p::tl ->
	let () = 
	  try
	    format_derivation (Printf.sprintf "%s   " prefix) p (PredicateMap.find p map) pred_table cst_table map set
	  with
	  | Not_found -> Printf.fprintf stdout "%s" (ASPred.to_string p pred_table cst_table)   in
	let () = format_premises2 prefix tl false  pred_table cst_table map set in
	Printf.fprintf stdout ""
	  

    let add_map_to_premises_to_buffer b pred_table cst_table map =
      PredicateMap.iter
	(fun k v ->  
	  PremiseSet.iter
	    (fun premise ->
	      Buffer.add_string
		b
		(Printf.sprintf
		   "%s <- %s\n"
		   (ASPred.to_string k pred_table cst_table)
		   (Premise.to_string premise pred_table cst_table)))
	    v)
	map




    let facts_to_string facts pred_table cst_table =
      let buff=Buffer.create 100 in
      let () = add_map_to_facts_to_buffer buff pred_table cst_table facts in 
      Buffer.contents buff


    let add_to_map_to_set k v m =
      let current_set =
	try
	  PredicateMap.find k m
	with
	| Not_found -> PremiseSet.empty in 
      PredicateMap.add k (PremiseSet.add v current_set) m

  end
    
  module Rule =
  struct
    
    (** In a [rule], all the compoments of all the predicates
	are stored in a {! UnionFind} indexed data structure. We assume
	here that from [1] to [lhs.arity] the components of the left
	hand side predicate are stored, then from [lhs.arity+1] to
	[lhs.arity+(hd rhs).arity] the components of the first predicate
	on the right hand side are stored, etc. It is assumed that this
	structure is correct (no cycle, links within the range, etc.) *)
    type rule={id:int;
	       lhs:Predicate.predicate;
	       e_rhs:Predicate.predicate list;
	       i_rhs:Predicate.predicate list;
	       content:ConstGen.id UF.t;
		 (* TODO: Maybe put the label of the predicate in the
		    content in order to enforce checking of the current
		    instantiation *)
(*	       abs_rule:ASRule.rule;*)
	      }
      
      
  (** [add_pred_arg_to_content arguments (content,idx,mapped_vars)]
      returns a triple (content',idx',mapped_vars') where [content']
      is the list [content] to which has been added {e *in the reverse
      order*} the information from [arguments]. The update is such
      that if the argument of [arguments] is a [Var i] then it is
      replaced by a [Link_to j] such that [j] is the index at which
      the variable [Var i] was met for the first time (it is stored in
      [mapped_vars]. If the argument is a [Const c], then a [Value c]
      is added at the current position. [idx'] is the value of the
      next position if another list of arguments has to be added. And
      [mapped_vars'] is a map from variables [Var i] to positions
      (i.e. [int]) in which these variables first occur in [content']
      - [arguments] is the list of the arguments of some predicate
      - [content] is a list meant to become the content of a rule,
      i.e. an indexed storage data structure that is meant to be
      extended with [arguments]. *BE CAREFUL: IT COMES IN INVERSE
      ORDER*
      - [idx] is the index to be given for the next element of
      [content]
      - [mapped_vars] is a mapping from [P.Var i] variables to the
      index at which they've been stored in [content]. When such a
      variable is met for the first time, as expected in the
      UnionFind data structure, the content at [idx] is [Link_to]'ed
      itself. *)
    let add_pred_arguments_to_content arguments (content,idx,mapped_vars) =
      List.fold_left
	(fun (cont,i,vars) (arg : ASPred.term) -> 
	  match arg with
	  | ASPred.Var v -> 
	    begin
	      try 
		let var_index = VarGen.IdMap.find v vars in
		((UF.Link_to var_index) :: cont,i+1,vars) with
	      | Not_found -> 
		LOG "I met a new variable and put it at index %d" i LEVEL TRACE;
		((UF.Link_to i) :: cont,i+1,VarGen.IdMap.add v i vars)
	    end
	  | ASPred.Const c -> ((UF.Value c) :: cont,i+1,vars))
	(content,idx,mapped_vars)
	arguments
	
  (** [make_rule r] returns an internal rule, that is one whose
      content is now a {! UnionFind.UnionFind} indexed data
      structure *)
	
    let make_rule {ASRule.id=id;ASRule.lhs=lhs;ASRule.e_rhs=e_rhs;ASRule.i_rhs=i_rhs} =
    (* Be careful, the list of the rhs is reversed *)
      LOG "Preparing the lhs content..." LEVEL TRACE;
      let lhs_content=
	add_pred_arguments_to_content lhs.ASPred.arguments ([],1,VarGen.IdMap.empty) in
      LOG "Done." LEVEL TRACE;
      LOG "Preparing the e_rhs..." LEVEL TRACE;
      let e_rhs,e_rhs_content =
	List.fold_left
	  (fun (rhs,content) {ASPred.p_id=n;ASPred.arity=k;ASPred.arguments=pred_args} ->
	    ({Predicate.p_id=n;Predicate.arity=k} :: rhs,
	     add_pred_arguments_to_content pred_args content))
	  ([],lhs_content)
	  e_rhs in
      LOG "Done." LEVEL TRACE;
      LOG "Preparing the i_rhs..." LEVEL TRACE;
      let i_rhs,(content,_,_) =
	List.fold_left
	  (fun (rhs,content) {ASPred.p_id=n;ASPred.arity=k;ASPred.arguments=pred_args} ->
	    ({Predicate.p_id=n;Predicate.arity=k} :: rhs,
	     add_pred_arguments_to_content pred_args content))
	  ([],e_rhs_content)
	  i_rhs in
      LOG "Done. Content is of size %d" (List.length content) LEVEL TRACE;
      let internal_content = UF.create (List.rev content) in
      LOG "It is represented by:" LEVEL TRACE;
      let () =
	List.iter (fun c -> LOG c LEVEL TRACE) (Bolt.Utils.split "\n" (UF.to_string internal_content)) in
      {id=id;
       lhs=Predicate.make_predicate lhs;
       e_rhs=List.rev e_rhs;
       i_rhs=List.rev i_rhs;
       content=internal_content
      }
	
  (* the [dag] parameter [h] is meant to be the components of some
     predicate or rule *)
    let cyclic_unify i j h =
      match UF.cyclic i h with
      | true,_ -> raise Fails
      | _, h' -> 
	(try UF.union i j h with
	| UF.Union_Failure -> raise Fails)

	  
    (** [extract_consequence r content] returns a fact from
	content. The arguments are of the form [Const c] or [Var v]
	(that is something of type {!
	Datalog_AbstractSyntax.AbstractSyntax.Predicate.term}). When
	it is a [Var v], it means that when this variable range over
	the constants of the program, it still are facts (=
	provable). *)
    let extract_consequence r content =
      let args,_,_= 
	List.fold_left 
	  (fun (args,varmap,vargen) elt ->
	    match elt with 
	    | UF.Value v -> (ASPred.Const v )::args,varmap,vargen
	    | UF.Link_to i -> 
	      let new_var,new_varmap,new_vargen = 
		try
		  Utils.IntMap.find i varmap,varmap,vargen
		with
		| Not_found -> let n_v,n_vg=VarGen.get_fresh_id vargen in
			       n_v,Utils.IntMap.add i n_v varmap,n_vg in
	      (ASPred.Var new_var)::args,new_varmap,new_vargen )
	  ([],Utils.IntMap.empty,VarGen.init ())
	  (UF.extract (r.lhs.Predicate.arity) content) in
      {ASPred.p_id=r.lhs.Predicate.p_id;
       ASPred.arity=r.lhs.Predicate.arity;
       ASPred.arguments=List.rev args }
    (* TODO: Directly extract from content, then the list would be
       crossed only once *)
	    
    (** [to_abstract r content] returns a datalog abstract syntax rule
	where the arguments of all (datalog abstract syntax)
	predicates have been computed using [content]. *)
    let to_abstract {id=id;lhs=lhs;e_rhs=e_rhs;i_rhs=i_rhs} content pred_table =
      LOG "Going to work with the following content:" LEVEL TRACE;
      let () =
	List.iter
	  (fun s -> LOG s LEVEL TRACE)
	  (Bolt.Utils.split "\n" (UF.to_string content)) in
      let abs_lhs,vars,vargen=Predicate.to_abstract lhs (1,content) (Utils.IntMap.empty,VarGen.init ()) pred_table in
      let abs_e_rhs,start',vars',vargen'=Predicate.lst_to_abstract e_rhs (1+lhs.Predicate.arity,content) (vars,vargen) pred_table in
      let abs_i_rhs,_,_,_ = Predicate.lst_to_abstract i_rhs (start',content) (vars',vargen') pred_table in
      {ASRule.id=id;
       ASRule.lhs=abs_lhs;
       ASRule.e_rhs=abs_e_rhs;
       ASRule.i_rhs=abs_i_rhs
      }


    (** [FactArray] is a module implementing a traversal of facts using
	the {! ArrayTraversal.Make} functor. The [update] function is
	such that we don't consider cells (i.e. facts) that don't unify
	with the rule (i.e. a {! UF.Union_Failure} exception was
	raised).*)
    module FactArray=ArrayTraversal.Make2(
      struct
	type cell = Predicate.FactSet.elt (*P.fact *)
  	type state = (int*(ConstGen.id UF.t))*(cell list)
	(* The state [(i,c),lst] stores the next index [i] of the
	   content [c] where the update should start start, and [lst]
	   keep track of the facts against which the content has been
	   unified. {e Be careful:} it stores them in the reverse
	   order.*)

	module CellSet=Predicate.FactSet
	let update (s,cells) c =
	  try 
	    Some (Predicate.instantiate_with c s,c::cells)
	  with
	  | UF.Union_Failure -> None
      end
    )
      
    (** [immediate_consequence_of_rule r db] returns a list of facts
	generated by the rule [r] using the facts stored in [db]. {e
	*these facts are not added to [db] when collecting the new
	facts*}.

	Note that it is important that resulting states need to be
	processed otherwise they will be lost in backtracking when using
	{! PersistentArray}.*)
    let rec immediate_consequence_of_rule r db =
    (* We collect all the contents compatible with the facts of the
       database corresponding to intensional predicates *)
      let make_search_array_i_pred =
	List.map (fun pred -> Predicate.PredMap.find pred.Predicate.p_id db) r.i_rhs in
    (* We define the function to be run on each reached end state of
       the instantiation with the extensional predicates *)
      let resume_on_i_pred acc state =
	FactArray.collect_results
	  (fun l_acc ((_,content),_) -> (extract_consequence r content)::l_acc)
	  acc
	state
	make_search_array_i_pred in
    (* We now collect all the contents compatible with the facts of
       the extensional database (facts of the database corresponding
       to extensional predicates). *)
    let make_search_array_e_pred =
      List.map (fun pred -> Predicate.PredMap.find pred.Predicate.p_id db) r.e_rhs in
    FactArray.collect_results
      (fun acc s -> resume_on_i_pred acc s)
      []
      ((r.lhs.Predicate.arity+1,r.content),[])
      make_search_array_e_pred
      
  (** [temp r time (rev_pred_lst,delta_position,pred_lst) e_facts
      time_indexed_intensional_facts
      time_indexed_delta_intensional_facts] returns a list ot new
      facts that are deduced from [temp]{^ [time+1]}{_ [S]} where [S] is
      the head predicate of the rule [r], [delta_position] the index
      of the intensional predicate that is under focus as described in
      {{: http://webdam.inria.fr/Alice/pdfs/Chapter-13.pdf} Chap. 13
      of "Foundations of Databases", Abiteboul, Hull, and Vianu}
      (p.315), [rev_pred_list] (resp.  [pred_lst]) the lists of
      predicates in the rule that precede [delta_position]
      (resp. [follow]) *)
  let temp r time (rev_pred_lst,delta_position,pred_lst) e_facts time_indexed_intensional_facts time_indexed_delta_intensional_facts agg_function start =
    (* We collect all the contents compatible with the facts of the
       intensional database *)
    let make_search_array_i_pred =
      let delta_facts=
	Predicate.PredMap.find delta_position.Predicate.p_id (Predicate.Indexed_Facts.find time time_indexed_delta_intensional_facts) in
      let end_pred_facts =
	List.map
	  (fun pred -> Predicate.PredMap.find pred.Predicate.p_id (Predicate.Indexed_Facts.find (time-1) time_indexed_intensional_facts))
	  pred_lst in
      List.fold_left
	(fun acc pred ->
	  (Predicate.PredMap.find pred.Predicate.p_id (Predicate.Indexed_Facts.find time time_indexed_intensional_facts))::acc)
	(delta_facts::end_pred_facts)
	rev_pred_lst in
    (* We define the function to be run on each reached end state of
       the instantiation with the extensional predicates *)
    let resume_on_i_pred acc state =
      FactArray.collect_results
	(fun l_acc ((_,content),premises) -> agg_function ((extract_consequence r content),premises) l_acc)
	acc
	state
	make_search_array_i_pred in
    (* We now collect all the contents compatible with the
       facts of the extensional database *)
    let make_search_array_e_pred =
      List.map (fun pred -> Predicate.PredMap.find pred.Predicate.p_id e_facts) r.e_rhs in
    FactArray.collect_results
      (fun acc s -> resume_on_i_pred acc s)
      start
      ((r.lhs.Predicate.arity+1,r.content),[])
      make_search_array_e_pred
  end

  module Program =
  struct
    type program = {rules:Rule.rule list Predicate.PredMap.t;
		  (* the list of the rules of the program indexed by
		     the id of this predicate *)
		    edb:ASPred.pred_id list;
		  (* the list of the ids of the extensional predicates *)
		    edb_facts:Predicate.FactSet.t Predicate.PredMap.t;
		    (* a map from predicate ids to facts for this
		       predicate*)
		    idb:ASPred.pred_id list;
		    (* the list of the ids of the intensional predicates *)
		    pred_table: ASPred.PredIdTable.table;
		 (* the table to record the translation from ids to
		    sym of the predicate *)
		    const_table: ConstGen.Table.table;
		 (* the table to record the translation from ids to
		    sym of the constants *)
		   }
      
    let extend k v map_list =
      try
	let lst=Predicate.PredMap.find k map_list in
	Predicate.PredMap.add k (v::lst) map_list
      with
      | Not_found -> Predicate.PredMap.add k [v] map_list

    let extend_map_to_set k v map_to_set =
      let current_set = 
	try
	  Predicate.PredMap.find k map_to_set
	with
	| Not_found -> Predicate.FactSet.empty in
      Predicate.PredMap.add k (Predicate.FactSet.add v current_set) map_to_set

	
    let make_program {ASProg.rules=r;ASProg.pred_table=pred_table;ASProg.const_table=cst_table;ASProg.i_preds=i_preds} =
      let rules,e_facts = ASRule.Rules.fold
	(fun ({ASRule.lhs=lhs} as r) (acc,e_facts) ->
	  LOG "Dealing with rule:\t%s" (ASRule.rule_to_string r pred_table cst_table) LEVEL TRACE;
	  let new_rule = Rule.make_rule r in
	  let updated_e_facts = 
	    if not (ASPred.PredIds.mem lhs.ASPred.p_id i_preds) then
	      extend_map_to_set lhs.ASPred.p_id lhs e_facts 
	    else
	      e_facts in
	  extend lhs.ASPred.p_id new_rule acc,updated_e_facts)
	r
	(Predicate.PredMap.empty,Predicate.PredMap.empty) in
      LOG "All rules done." LEVEL TRACE;
      LOG "Now separate the e and i predicates." LEVEL TRACE;
      let edb,idb=
	ASPred.PredIdTable.fold
	  (fun k _ (e,i) ->
	    if ASPred.PredIds.mem k i_preds then
	      (e,k::i)
	    else
	      (k::e,i))
	  pred_table
	  ([],[]) in
      LOG "Done." LEVEL TRACE;
      {rules=rules;edb=edb;edb_facts=e_facts;idb=idb;pred_table=pred_table;const_table=cst_table}
	
	
    let to_abstract {rules=r;idb=idb;pred_table=pred_table;const_table=cst_table} =
      LOG "Transforming internat rules into abastract ones..." LEVEL TRACE;
      let rules = 
	Predicate.PredMap.fold
	  (fun _ rules acc -> 
	    List.fold_left
	      (fun acc' rule -> 
		ASRule.Rules.add (Rule.to_abstract rule rule.Rule.content pred_table) acc')
	      acc
	      rules)
	  r
	  ASRule.Rules.empty in
      LOG "Done." LEVEL TRACE;
      let i_preds=
	List.fold_left
	  (fun acc id -> ASPred.PredIds.add id acc)
	  ASPred.PredIds.empty
	  idb in
      {ASProg.rules=rules;ASProg.pred_table=pred_table;ASProg.const_table=cst_table;ASProg.i_preds=i_preds}
	
	
	
    let all_temp_results_for_predicate s time {rules=rules} e_facts time_indexed_intensional_facts time_indexed_delta_intensional_facts =
      List.fold_left
	(fun acc r ->
	  let zip=Focused_list.init r.Rule.i_rhs in
	  Focused_list.fold
	    (fun l_acc focus -> Rule.temp r time focus e_facts time_indexed_intensional_facts time_indexed_delta_intensional_facts  (fun hd tl -> hd::tl) l_acc)
	    acc
	    zip)
	[]
	(Predicate.PredMap.find s.Predicate.p_id rules)
	
  (** [temp_facts r e_facts previous_step_facts facts delta_facts
      agg_f start] returns the result of applying [agg_f] to [start]
      and to all the facts that are deduced from [temp]{^ [time+1]}{_
      [S]} where [S] is the head predicate of the rule [r] and [temp]
      is the set of temporary rules associated with [r] as in the
      algorithm described in {{:
      http://webdam.inria.fr/Alice/pdfs/Chapter-13.pdf} Chap. 13 of
      "Foundations of Databases", Abiteboul, Hull, and Vianu} (p.315).
      
      [previous_step_facts] and [facts] denote the intentional facts
      at the two required successive steps and [delta_facts] denote
      the new facts that are computed during this step. *)
	
  (* TODO: if a set of facts for a predicate of the rhs is empty, we
     can stop the computation *)
    let temp_facts r e_facts previous_step_facts facts delta_facts agg_function start pred_table cst_table =
      LOG "Scanning the rule: %s" (ASRule.rule_to_string (Rule.to_abstract r r.Rule.content pred_table) pred_table cst_table) LEVEL TRACE;
      (* We first collect all the contents compatible with the facts of
	 the intensional database. They depend on the intensional
	 predicate [delta_position] and the ones that are before it
	 ([rev_pred_lst]) and the ones that are after it
	 ([pred_lst]). This triple correspond to a {!Focused_list.t}
	 type. *)
      let make_search_array_i_pred (rev_pred_lst,delta_position,pred_lst) =
	let facts_at_delta_position=
	  try
	    Predicate.PredMap.find delta_position.Predicate.p_id delta_facts
	  with
	  | Not_found -> Predicate.FactSet.empty in
	let end_pred_facts =
	  List.map
	    (fun pred -> 
	      try
		Predicate.PredMap.find pred.Predicate.p_id previous_step_facts
	      with
	      | Not_found -> Predicate.FactSet.empty)
	    pred_lst in
	List.fold_left
	  (fun acc pred ->
	    try
	      (Predicate.PredMap.find pred.Predicate.p_id facts)::acc
	    with
	    | Not_found -> acc)
	  (facts_at_delta_position::end_pred_facts)
	  rev_pred_lst in
      (* We define the function to be run on each reached end state of
	 the instantiation with the extensional predicates. This
	 function will run a result collection (with
	 [FactArray.collect_results]) for each of the possible
	 [delta_facts], that is for each of the possible [Focused_list]
	 that can be reach from [zip] (including [zip] itself). *)
      let resume_on_i_pred acc (((i,content),premises) as state) =
	match r.Rule.i_rhs with
	| [] -> agg_function ((Rule.extract_consequence r content),premises) acc
	| _ -> 
	(* We now init the focused list corresponding to the intensional
	   predicates of the rule [r] *)
	  let zip=Focused_list.init r.Rule.i_rhs in
	  Focused_list.fold
	    (fun l_acc focus ->
	    (* For a given focus in the intensional list of predicates
	       of [r], we extract all the possible facts from the rule
	       [r] *)
	      Rule.FactArray.collect_results
		(fun ll_acc ((_,content),premises) -> agg_function ((Rule.extract_consequence r content),premises) ll_acc)
		l_acc
		state
		(make_search_array_i_pred focus))
	    acc
	    zip in
      (* We now collect all the contents compatible with the
	 facts of the extensional database *)
      let make_search_array_e_pred =
	List.map (fun pred -> Predicate.PredMap.find pred.Predicate.p_id e_facts) r.Rule.e_rhs in
      Rule.FactArray.collect_results
	(fun acc s -> 
	  (* For each partial completion of the rule on the extensional
	     database, we need to take into account the remaining
	     intensional predicates. *)
	  resume_on_i_pred acc s)
	start
	((r.Rule.lhs.Predicate.arity+1,r.Rule.content),[])
	make_search_array_e_pred
	
    let custom_find k map =
      try
	Predicate.PredMap.find k map
      with
      | Not_found -> Predicate.FactSet.empty


  (** [p_semantics_for_predicate s prog e_facts previous_step_facts
      facts delta_facts] returns a set of all the facts that can
      deduced by all the rules in [prog] at a given step and whose lhs
      predicate is [s] when the edb is [e_facts], the step has
      produced [facts] and the previous step has produced
      [previous_step_facts] and the variation of facts at this step
      are [delta_facts].
      
      It corresponds to [P]{^ [time]}{_ [S]} [(edb,T]{^ [time -1]}{_
      [1]}[,...,T]{^ [time-1]}{_ [l]}[,T]{^ [time]}{_ [1]}[,...,T]{^
      [time]}{_ [l]}[, Delta]{^ [time]}{_ [T]{_ [1]}},...,[Delta]{^
      [time]}{_ [T]{_ [l]}}) in {{:
      http://webdam.inria.fr/Alice/pdfs/Chapter-13.pdf} Chap. 13 of
      "Foundations of Databases", Abiteboul, Hull, and Vianu} *)
    let p_semantics_for_predicate s_id prog e_facts previous_step_facts facts delta_facts derivations =
      List.fold_left
	(fun acc r ->
	  temp_facts
	    r
	    e_facts
	    previous_step_facts
	    facts
	    delta_facts
	    (fun (new_fact,from_premises) (new_fact_set,new_fact_derivations) -> 
	      (Predicate.conditionnal_add
		new_fact
		new_fact_set
		(custom_find r.Rule.lhs.Predicate.p_id previous_step_facts)
		(custom_find r.Rule.lhs.Predicate.p_id delta_facts),
	       Predicate.add_to_map_to_set new_fact from_premises new_fact_derivations))
	    acc
	    prog.pred_table
	    prog.const_table)
	(Predicate.FactSet.empty,derivations)
	(Predicate.PredMap.find s_id prog.rules)
	
    let seminaive prog =
      (** [seminaive_aux facts delta_facts] returns [(S]{^
	  [i]}[,][Delta]{^ [i+1]}{_ [S]}[)] for all [S] when [facts]
	  corresponds to [S]{^ [i-1]} for all [S] and [delta_facts] to
	  [Delta]{^ [i]}{_ [S]} for all [S] *)
      let rec seminaive_aux facts delta_facts derivations =
	(* TODO: Check that PredMap has all intensional predicates of
	   prog *)
	let new_facts = 
	  Predicate.PredMap.merge
	    (fun pred_id v1 v2 ->
	      match v1,v2 with
	      | Some l1,Some l2 -> Some (Predicate.FactSet.union l1 l2)
	      | Some _ as v,None -> v
	      | None, (Some _ as v) -> v
	      | None,None -> None)
	    facts
	    delta_facts in
	let new_delta_facts,new_derivations_for_all_i_pred = 
	  List.fold_left
	    (fun (acc,derivations) pred ->
	      LOG "Trying to derive facts for: %s" (ASPred.to_string {ASPred.p_id=pred;ASPred.arity=0;ASPred.arguments=[]} prog.pred_table prog.const_table) LEVEL DEBUG;
	      let new_facts_for_pred,new_derivations=
		p_semantics_for_predicate
		  pred
		  prog
		  prog.edb_facts
		  facts
		  new_facts
		  delta_facts
		  derivations in
	      if Predicate.FactSet.is_empty new_facts_for_pred then
		acc,new_derivations
	      else
		Predicate.PredMap.add
		  pred
		  new_facts_for_pred
		  acc,new_derivations) 
	    (Predicate.PredMap.empty,derivations)
	    prog.idb  in 
	LOG "% d new facts:" (Predicate.PredMap.fold (fun _ v acc -> acc+(Predicate.FactSet.cardinal v)) new_delta_facts 0) LEVEL DEBUG;
	let () = 
	  List.iter
	    (fun s -> LOG s LEVEL DEBUG)
	    (Bolt.Utils.split "\n" (Predicate.facts_to_string new_delta_facts prog.pred_table prog.const_table)) in
	(new_facts,new_delta_facts,new_derivations_for_all_i_pred) in
      (** [seminaive_rec (facts,delta_facts)] returns the result when
	  the fixpoint is reached, ie when [seminaive_aux facts
	  delta_facts] does not produce any new fact. This is the
	  iteration at step 5 in the seminaive algo. *)
      let rec seminaive_rec (facts,delta_facts,derivations)= 
	if Predicate.PredMap.is_empty delta_facts then
	  facts,derivations
	else
	  seminaive_rec (seminaive_aux facts delta_facts derivations) in
      let first_step_results = seminaive_aux prog.edb_facts Predicate.PredMap.empty Predicate.PredicateMap.empty in
      seminaive_rec first_step_results
	
	
  end
    
    
end
    
    
