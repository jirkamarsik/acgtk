%mltop {
  open Abstract_syntax
  module Env = Set.Make(String)

  type local_data =
    | Signature of Abstract_sig.t
    | Abs_and_obj of Abstract_sig.t * Abstract_sig.t
    | Env of Environment.t
}

{
  open Dyp
  open Entry

  exception No_sig

  type type_or_cst =
    | Type
    | Cst

  exception Is_type
  exception Is_cst

  let emit_parse_error e loc = raise (Error.Error (Error.Parse_error (e,loc)))

  let local_data = None



  let abs x l t = function
    | Abstract_sig.Linear -> Abstract_sig.LAbs (x,t,l)
(*    | Abstract_sig.Non_linear -> Abstract_sig.Abs (x,l,t) *)

  let rec multiple_abs e ws k_a l ids t k =
    match ids with
      | [] -> k (t e ws)
      | [a,l_a] ->
	  let new_t,new_ws = t (Env.add a e) ws in
	    k (abs a l_a new_t k_a,new_ws)
      | (a,l_a)::((_,l_b)::_ as tl) -> 
	  let new_env = Env.add a e in
	    multiple_abs new_env ws k_a l_b tl t (fun r -> k (abs a l (fst r) k_a,(snd r)))

  let bind c x l t = Abstract_sig.App (c,Abstract_sig.LAbs (x,t,l),l)

  let rec multiple_bind e ws binder l ids t k =
    match ids with
      | [] -> k (t e ws)
      | [a,l_a] ->
	  let new_t,new_ws = t (Env.add a e) ws in
	    k (bind binder a l_a new_t,new_ws)
      | (a,l_a)::((_,l_b)::_ as tl) ->
	  let new_env = Env.add a e in
	    multiple_bind new_env ws binder l_b tl t (fun r -> k (bind binder a l (fst r),(snd r)))

(*  let empty_sig = Abstract_sig.empty ""*)

  let get_sig_value = function
    | None -> raise No_sig
    | Some (Signature s) -> s
    | Some (Abs_and_obj (_,o)) -> o
    | Some (Env _) -> failwith "Bug: looking for a signature while env is the current local data"

  let get_abs_and_obj_sig_value = function
    | None -> raise No_sig
    | Some (Signature _) -> failwith "Bug: looking for an abs_obj while signature is the current local data"
    | Some (Abs_and_obj (a,o)) -> a,o
    | Some (Env _) -> failwith "Bug: looking for an abs_obj while env is the current local data"


  let get_env_value = function
    | None -> Environment.empty
    | Some (Env e) -> e
    | Some (Abs_and_obj _) -> failwith "Bug: looking for an env while abs_obj is the current local data"
    | Some (Signature _) -> failwith "Bug: looking for an env while signature is the current local data"


  let raise_expect v (p1,p2) =
    let s = Entry.valuation_to_string v in
      raise (Error.Error (Error.Lexer_error (Error.Expect s,(p1,p2))))

(*end*)

}


%token
  EOI
<Abstract_sig.location> EQUAL
<Abstract_sig.location> SEMICOLON
<Abstract_sig.location> COLON
<Abstract_sig.location> COMMA
<Abstract_sig.location> LPAREN
<Abstract_sig.location> RPAREN
<Abstract_sig.location> DOT
<Abstract_sig.location> SIG_OPEN
<Abstract_sig.location> LEX_OPEN
<Abstract_sig.location> END_OF_DEC
<Abstract_sig.location> TYPE
<Abstract_sig.location> PREFIX
<Abstract_sig.location> INFIX
<Abstract_sig.location> BINDER
<Abstract_sig.location> LAMBDA
<Abstract_sig.location> LAMBDA0
<Abstract_sig.location> ARROW
<Abstract_sig.location> COLON_EQUAL
<Abstract_sig.location> LIN_ARROW
<(string*Abstract_sig.location)> IDENT
<(string*Abstract_sig.location)> SYMBOL
  
%start <Environment.t> data
%start <(Env.t -> Error.warning list -> (Abstract_sig.term * Error.warning list))> term
%start <Abstract_sig.term> term_alone
  
%relation atom<app<sym_app<binder atom_type<arrow_type

%local_data_type <(local_data option)>
  
%%

  data:
| EOI {get_env_value dyp.last_local_data}
| signature[s] ...@{s,[Local_data (Some (Env (Environment.insert (Environment.Signature s) (get_env_value dyp.last_local_data))))]} data[d] {d}
| lexicon[l] ...@{l,[Local_data (Some (Env (Environment.insert (Environment.Lexicon l) (get_env_value dyp.last_local_data))))]} data[d] {d}
  
/*  signatures :
| EOI {fun env -> env}
| signature[s] signatures[e] {fun env -> e (Environment.insert (Environment.Signature s) env)}
*/
      signature : 
| SIG_OPEN sig_ident EQUAL sig_entries END_OF_DEC {$4}
| SIG_OPEN sig_ident EQUAL sig_entries SEMICOLON END_OF_DEC {$4}
      
      sig_ident :
| IDENT @{$1,[Local_data (Some (Signature (Abstract_sig.empty $1)))]}
	  
	  lexicon : 
| LEX_OPEN lex_opening[l] EQUAL lex_entries[e] END_OF_DEC {e l}
| LEX_OPEN lex_opening[l] EQUAL lex_entries[e] SEMICOLON END_OF_DEC {e l}


      lex_opening :
| IDENT[name] LPAREN IDENT[abs_name,abs_loc] RPAREN COLON IDENT[obj_name,obj_loc] @{
    let env = get_env_value dyp.last_local_data in
    let abs = 
      try
	Environment.get_signature abs_name env
      with
	| Environment.Signature_not_found _ -> emit_parse_error (Error.No_such_signature abs_name) abs_loc in
    let obj = 
      try
	Environment.get_signature obj_name env
      with
	| Environment.Signature_not_found _ -> emit_parse_error (Error.No_such_signature obj_name) obj_loc in
    let lex = Abstract_lex.empty name ~abs:abs ~obj:obj in
      lex,[Local_data (Some (Abs_and_obj (abs,obj)))]}

	  sig_entries :
| sig_entry @{$1,[Local_data (Some (Signature $1))]}
| sig_entry SEMICOLON sig_entries @{$3,[Local_data (Some (Signature $3))]}

      sig_entry :
| type_declaration @{$1,[Local_data dyp.last_local_data]}
| type_definition @{$1,[Local_data dyp.last_local_data]}
| term_declaration @{$1,[Local_data dyp.last_local_data]}
| term_definition @{$1,[Local_data dyp.last_local_data]}

      
      type_declaration :
| comma_ids COLON TYPE @{let s = get_sig_value dyp.last_local_data in
			let new_sig =
			  List.fold_left
			    (fun acc id ->
			       try
				 Abstract_sig.add_entry (Abstract_sig.Type_decl (fst id,snd id,Abstract_sig.K [])) acc
			       with
				 | Abstract_sig.Duplicate_type_definition -> 
				     let pos1,pos2= snd id in
				       emit_parse_error (Error.Duplicated_type (fst id)) (pos1,pos2))
			    s
			    $1 in
			  new_sig,[Local_data (Some (Signature new_sig))]}

	  comma_ids :
| IDENT[id] {[id]}
| IDENT[id] COMMA comma_ids[id_list] {id::id_list}

      type_definition :
| IDENT EQUAL type_expression COLON TYPE @{let s = get_sig_value dyp.last_local_data in
					   let new_sig =
					     try
					       Abstract_sig.add_entry (Abstract_sig.Type_def (fst $1,snd $1,fst ($3 s))) s
					     with
					       | Abstract_sig.Duplicate_type_definition -> 
						   let pos1,pos2= snd $1 in
						     emit_parse_error (Error.Duplicated_type (fst $1)) (pos1,pos2) in 
					     new_sig,[Local_data (Some (Signature new_sig))]}
| IDENT EQUAL type_expression COLON type_expression {let s = get_sig_value dyp.last_local_data in
						       try
							 let _ = $3 s in
							   raise_expect Entry.Type_kwd (snd ($5 s))
						       with
							 | Error.Error (Error.Parse_error ((Error.Unknown_type _),_)) -> raise Dyp.Giveup}
| IDENT EQUAL type_expression COLON term {let s = get_sig_value dyp.last_local_data in
					    try
					      let _ = $3 s in
					      let l = Abstract_sig.get_term_location (fst ($5 Env.empty [])) in
						raise_expect Entry.Type_kwd l
					    with
					      | Error.Error (Error.Parse_error ((Error.Unknown_type _),_)) -> raise Dyp.Giveup
					      | Error.Error (Error.Parse_error ((Error.Unknown_constant _),(p1,p2))) -> raise_expect Entry.Type_kwd (p1,p2)}
	  
	  type_expression :
| atomic_type {$1} atom_type
| atomic_type (<= atom_type) LIN_ARROW type_expression (<=arrow_type)  {fun sg ->
									  let ty1,loc1 = $1 sg in
									  let ty2,loc2 = $3 sg in
									  let new_loc = Abstract_sig.new_loc loc1 loc2 in Abstract_sig.Linear_arrow (ty1,ty2,new_loc),new_loc} arrow_type
      
      atomic_type :
| IDENT {fun sg ->
	   let id,((pos1,pos2) as l) = $1 in
	     match Abstract_sig.is_type id sg with
	       | true -> Abstract_sig.Type_atom (id,l,[]),l
	       | false -> emit_parse_error (Error.Unknown_type id) (pos1,pos2)} atom_type
| LPAREN type_expression RPAREN {fun sg -> fst ($2 sg),Abstract_sig.new_loc $1 $3} atom_type
      
      term_declaration :
| term_dec_start COLON type_expression  @{let s = get_sig_value dyp.last_local_data in
					  let new_sig =
					    List.fold_left
					      (fun acc (id,kind,loc) -> 
						 try
						   Abstract_sig.add_entry (Abstract_sig.Term_decl (id,kind,loc,fst ($3 s))) acc
						 with
						   | Abstract_sig.Duplicate_term_definition -> 
						       let pos1,pos2= loc in
							 emit_parse_error (Error.Duplicated_term id) (pos1,pos2))
					      s
					      $1 in new_sig,[Local_data (Some (Signature new_sig))]}

	  term_dec_start : 
| comma_ids {List.map (fun (id,loc) -> (id,Abstract_sig.Default,loc)) $1}
| PREFIX SYMBOL[sym,l] {[sym,Abstract_sig.Prefix,l]} 
| INFIX SYMBOL[sym,l] {[sym,Abstract_sig.Infix,l]}
| BINDER IDENT {[fst $2,Abstract_sig.Binder,snd $2]}

      term_def_start : 
| IDENT {fst $1,Abstract_sig.Default,snd $1}
| PREFIX SYMBOL[sym,l] {(sym,Abstract_sig.Prefix,l)}
| INFIX SYMBOL[sym,l] {(sym,Abstract_sig.Infix,l)}
| BINDER IDENT {fst $2,Abstract_sig.Binder,snd $2}


      term_definition :
| term_def_start EQUAL term COLON type_expression @{let id,k,l = $1 in
						    let s = get_sig_value dyp.last_local_data in
						    let new_sig =
						      try
							let term_value,ws = $3 Env.empty [] in
							let new_sig2 = Abstract_sig.add_entry (Abstract_sig.Term_def (id,k,l,term_value,fst ($5 s))) s  in 
							  (match ws with
							    | [] -> new_sig2
							    | lst -> Abstract_sig.add_warnings ws new_sig2) with
							    | Abstract_sig.Duplicate_term_definition ->
								emit_parse_error (Error.Duplicated_term id) (fst l,snd l) in
						      new_sig,[Local_data (Some (Signature new_sig))]}
	  
	  term_alone :
| term EOI {fst ($1 Env.empty [])}	  

	  term :
| LAMBDA0  idents DOT term {
    let sg = get_sig_value dyp.last_local_data in
      fun env ws -> multiple_abs env ws Abstract_sig.Linear $1 $2 $4 (fun x -> x)} binder
| IDENT  idents DOT term {
    let sg = get_sig_value dyp.last_local_data in
(*    let () = Printf.printf "To parse a term, the current sig is: %s\n%!" (fst (Abstract_sig.name sg)) in *)
    let binder,((p1,p2) as l) = $1 in
      fun env ws -> 
	match Abstract_sig.is_constant binder sg with
	  | true,Some Abstract_sig.Binder -> multiple_bind env ws (Abstract_sig.Const(binder,l)) (snd $1) $2 $4 (fun x -> x)
	  | _ -> emit_parse_error (Error.Binder_expected binder) (p1,p2) } binder 
| application(<=app) {$1} app 
| atomic_term (<=atom) SYMBOL term (<=app) {let sg = get_sig_value dyp.last_local_data in
					     let id,((pos1,pos2) as l) = $2 in
					       match Abstract_sig.is_constant id sg with
						 | true,Some (Abstract_sig.Infix) -> 
						     let () = Error.unset_infix () in
						       (fun env ws->
							  let u1,ws1 = $1 env ws in
							  let u2,ws2 = $3 env ws1 in
							    (Abstract_sig.App (Abstract_sig.App(Abstract_sig.Const(id,l),u1,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) l),u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))),ws2)
						 | true,_ -> raise Dyp.Giveup
						 | _ -> emit_parse_error (Error.Unknown_constant id) (pos1,pos2)}  app 
      
      atomic_term :
| IDENT {let id,l=$1 in
	 let s = get_sig_value dyp.last_local_data in 
	 let is_constant,_ = Abstract_sig.is_constant id s in
	   fun env ws -> 
	     match Env.mem id env,is_constant with
	       | true,false -> Abstract_sig.Var (id,l),ws
	       | true,true -> Abstract_sig.Var (id,l),(Error.Variable_or_constant (id,fst l,snd l))::ws
	       | false,true -> Abstract_sig.Const (id,l),ws
	       | false,false ->emit_parse_error (Error.Unknown_constant id) (fst l,snd l)} atom
| LPAREN term RPAREN {$2} atom
| SYMBOL term {let sg = get_sig_value dyp.last_local_data in
	       let id,((pos1,pos2) as l) = $1 in
		 match Abstract_sig.is_constant id sg with
		   | true,Some (Abstract_sig.Prefix) -> 
		       (fun env ws ->
			  let u2,ws2 = $2 env ws in
			    (Abstract_sig.App(Abstract_sig.Const(id,l),u2,Abstract_sig.new_loc l (Abstract_sig.get_term_location u2))),ws2)
		   | true,_ -> 
		       let () = Error.set_infix $1 in
			 raise Dyp.Giveup
		   | _ -> emit_parse_error (Error.Unknown_constant id) (pos1,pos2)} atom 
      
      application :
| atomic_term(<=atom) {$1} app
| application(<=app) atomic_term(<=atom) {fun e ws ->
					      let u1,ws1 = $1 e ws in
					      let u2,ws2 = $2 e ws1 in
						(Abstract_sig.App(u1,u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))),ws2} app
      
      idents :
| {[]}
| IDENT idents {$1::$2}
      
      lex_entries :
/*| lex_entry[e] {fun lex -> e lex}*/
| {fun lex -> lex}
| lex_entry[e] lex_entries[es] {fun lex -> es (e lex)}
      
      lex_entry :
| comma_ids[ids] COLON_EQUAL term[t] SEMICOLON {
(*    let () = Printf.printf "Hop with %s!\n%!" (Utils.string_of_list " " fst ids) in*)
    let abs,obj = get_abs_and_obj_sig_value dyp.last_local_data in    
    let kind =
      List.fold_left
	(fun k (id,loc) ->
	   match k,fst (Abstract_sig.is_constant id abs) with
	     | (None|Some Cst),true -> Some Cst
	     | None,false ->
		 if (Abstract_sig.is_type id abs)
		 then
		   raise Dyp.Giveup 
		 else
		   emit_parse_error (Error.Unknown_constant id) loc
	     | Some Cst,false -> emit_parse_error (Error.Unknown_constant id) loc
	     | Some Type,_ -> failwith "Bug: should not occur")
	None
	ids in
(*    let () = Printf.printf "Going to compute the term\n%!" in*)
    let term = fst (t Env.empty []) in
(*    let () = Printf.printf "Succeeded!(%s)\n%!" (Abstract_sig.term_to_string term obj) in *)
      fun lex ->
	List.fold_left
	  (fun acc (id,loc) -> Abstract_lex.insert id (Abstract_lex.Constant (loc,term)) acc)
	  lex
	  ids}
| comma_ids[ids] COLON_EQUAL type_expression[ty] SEMICOLON {
    let abs,obj = get_abs_and_obj_sig_value dyp.last_local_data in    
    let kind =
      List.fold_left
	(fun k (id,loc) ->
	   match k,Abstract_sig.is_type id abs with
	     | (None|Some Type),true -> Some Type
	     | None,false ->
		 if fst (Abstract_sig.is_constant id abs)
		 then
		   raise Dyp.Giveup 
		 else
		   emit_parse_error (Error.Unknown_type id) loc
	     | Some Type,false -> emit_parse_error (Error.Unknown_type id) loc
	     | Some Cst,_ -> failwith "Bug: should not occur")
	None
	ids in
    let actual_type = fst (ty obj) in
      fun lex ->
	List.fold_left
	  (fun acc (id,loc) -> Abstract_lex.insert id (Abstract_lex.Type (loc,actual_type)) acc)
	  lex
	  ids}

%mlitop {
  open Abstract_syntax
  module Env : Set. S with type elt = String.t
  type local_data =
    | Signature of Abstract_sig.t
    | Abs_and_obj of Abstract_sig.t * Abstract_sig.t
    | Env of Environment.t
}
