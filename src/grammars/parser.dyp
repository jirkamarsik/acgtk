%mltop {
  open Abstract_syntax
  module Env = Set.Make(String)
}
{
  open Dyp
  open Entry

  exception No_sig

(*  let () = dypgen_verbose :=2 *)


  let local_data = None

(*  let pr s = Printf.fprintf stderr "%s\n%!" s *)

  let abs x l t = function
    | Abstract_sig.Linear -> Abstract_sig.LAbs (x,t,l)
(*    | Abstract_sig.Non_linear -> Abstract_sig.Abs (x,l,t) *)

  let rec multiple_abs e ws k_a l ids t k =
    match ids with
      | [] -> k (t e ws)
      | [a,l_a] ->
	  let new_t,new_ws = t (Env.add a e) ws in
	    k (abs a l_a new_t k_a,new_ws)
      | (a,l_a)::((_,l_b)::_ as tl) -> 
	  let new_env = Env.add a e in
	    multiple_abs new_env ws k_a l_b tl t (fun r -> k (abs a l (fst r) k_a,(snd r)))

  let bind c x l t = Abstract_sig.App (c,Abstract_sig.LAbs (x,t,l),l)

  let rec multiple_bind e ws binder l ids t k =
    match ids with
      | [] -> k (t e ws)
      | [a,l_a] ->
	  let new_t,new_ws = t (Env.add a e) ws in
	    k (bind binder a l_a new_t,new_ws)
      | (a,l_a)::((_,l_b)::_ as tl) ->
	  let new_env = Env.add a e in
	    multiple_bind new_env ws binder l_b tl t (fun r -> k (bind binder a l (fst r),(snd r)))

  let empty_sig = Abstract_sig.empty ""

  let get_value = function
    | None -> raise No_sig
    | Some s -> s

  let raise_expect v (p1,p2) =
    let s = Entry.valuation_to_string v in
      raise (Error.Error (Error.Lexer_error ((Error.Expect (s,p1,p2)))))

(*
  let add_prefix_rule sym =
    Dyp_symbols.atomic_term,
     [Ter Dyp_symbols.t_SYMBOL;
      Non_ter (Dyp_symbols.term,No_priority)],
    Dyp_priority_data.atom

  let add_prefix_action symbol =
    (fun dyp params ->
       let sg = get_value dyp.last_local_data in
       let sym,t = match params with
	 | [Obj_SYMBOL ((id,_) as s);Obj_term t] when id = symbol-> s, t
	 | [Obj_SYMBOL _; Obj_term _] -> raise Dyp.Giveup
	 | _ -> failwith "Could not add prefix action" in
       let id,((pos1,pos2) as l) = sym in
	 match Abstract_sig.is_constant id sg with
	   | true,Some (Abstract_sig.Prefix) -> 
	       (Obj_atomic_term
		  (fun env ws ->
		     let u2,ws2 = t env ws in
		       (Abstract_sig.App(Abstract_sig.Const(id,l),u2,Abstract_sig.new_loc l (Abstract_sig.get_term_location u2))),ws2),[])
	   | true,_ -> raise Dyp.Giveup
	   | _ -> raise (Error.emit_parse_error (Error.Unknown_constant (id,pos1,pos2))))
      
      
  let add_infix_rule sym =
    Dyp_symbols.term,
    [Non_ter (Dyp_symbols.term,Eq_priority Dyp_priority_data.atom);
     Ter Dyp_symbols.t_SYMBOL;
     Non_ter (Dyp_symbols.term,Eq_priority Dyp_priority_data.app)],
    Dyp_priority_data.app
      
  let add_infix_action symbol =
    (fun dyp params ->
       let sg = get_value dyp.last_local_data in
       let t1,sym,t2 = match params with
	 | [Obj_term t_1;Obj_SYMBOL ((id,_) as s);Obj_term t_2] when id = symbol-> t_1,s, t_2
	 | [Obj_term _;Obj_SYMBOL _; Obj_term _] -> raise Dyp.Giveup
	 | _ -> failwith "Could not add prefix action" in
       let id,((pos1,pos2) as l) = sym in
	 match Abstract_sig.is_constant id sg with
	   | true,Some (Abstract_sig.Infix) -> 
	       (Obj_term
		  (fun env ws->
		     let u1,ws1 = t1 env ws in
		     let u2,ws2 = t2 env ws1 in
		       (Abstract_sig.App (Abstract_sig.App(Abstract_sig.Const(id,l),u1,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) l),u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))),ws2),[])
	   | true,_ -> raise Dyp.Giveup
	   | _ -> raise (Error.emit_parse_error (Error.Unknown_constant (id,pos1,pos2))))
*)
}


%token
  EOI
<Abstract_sig.location> EQUAL
<Abstract_sig.location> SEMICOLON
<Abstract_sig.location> COLON
<Abstract_sig.location> COMMA
<Abstract_sig.location> LPAREN
<Abstract_sig.location> RPAREN
<Abstract_sig.location> DOT
<Abstract_sig.location> SIG_OPEN
<Abstract_sig.location> END_OF_DEC
<Abstract_sig.location> TYPE
<Abstract_sig.location> PREFIX
<Abstract_sig.location> INFIX
<Abstract_sig.location> BINDER
<Abstract_sig.location> LAMBDA
<Abstract_sig.location> LAMBDA0
<Abstract_sig.location> ARROW
<Abstract_sig.location> LIN_ARROW
<(string*Abstract_sig.location)> IDENT
<(string*Abstract_sig.location)> SYMBOL
  
%start <(Environment.content -> Environment.content)> signatures
%start <(Env.t -> Error.warning list -> (Abstract_sig.term * Error.warning list))> term
%start <Abstract_sig.term> term_alone
  
%relation atom<app<sym_app<binder atom_type<arrow_type

%local_data_type <(Abstract_sig.t option)>
  
%%
  
  signatures :
| EOI {fun env -> env}
| signature[s] signatures[e] {fun env -> e (Environment.Env.add (Abstract_sig.name s) s env)}

      signature : 
| SIG_OPEN ident EQUAL sig_entries END_OF_DEC {$4}
| SIG_OPEN ident EQUAL sig_entries SEMICOLON END_OF_DEC {$4}
      
      ident :
| IDENT @{$1,[Local_data (Some (Abstract_sig.empty (fst $1)))]}

	  sig_entries :
| sig_entry @{$1,[Local_data (Some $1)]}
| sig_entry SEMICOLON sig_entries @{$3,[Local_data (Some $3)]}

      sig_entry :
| type_declaration @{$1,[Local_data dyp.last_local_data]}
| type_definition @{$1,[Local_data dyp.last_local_data]}
| term_declaration @{$1,[Local_data dyp.last_local_data;Keep_grammar true]}
| term_definition @{$1,[Local_data dyp.last_local_data;Keep_grammar true]}

      
      type_declaration :
| comma_ids COLON TYPE @{let s = get_value dyp.last_local_data in
			let new_sig =
			  List.fold_left
			    (fun acc id ->
			       try
				 Abstract_sig.add_entry (Abstract_sig.Type_decl (fst id,snd id,Abstract_sig.K [])) acc
			       with
				 | Abstract_sig.Duplicate_type_definition -> 
				     let pos1,pos2= snd id in
				       raise (Error.emit_parse_error (Error.Duplicated_type (fst id,pos1,pos2))))
			    s
			    $1 in
			  new_sig,[Local_data (Some new_sig)]}

	  comma_ids :
| IDENT[id] {[id]}
| IDENT[id] COMMA comma_ids[id_list] {id::id_list}

      type_definition :
| IDENT EQUAL type_expression COLON TYPE @{let s = get_value dyp.last_local_data in
					   let new_sig =
					     try
					       Abstract_sig.add_entry (Abstract_sig.Type_def (fst $1,snd $1,fst ($3 s))) s
					     with
					       | Abstract_sig.Duplicate_type_definition -> 
						   let pos1,pos2= snd $1 in
						     raise (Error.emit_parse_error (Error.Duplicated_type (fst $1,pos1,pos2))) in 
					     new_sig,[Local_data (Some new_sig)]}
/*| IDENT EQUAL type_expression COLON type_expression {let s = get_value dyp.last_local_data in
						       raise_expect Entry.Type_kwd (snd ($5 s))}
| IDENT EQUAL type_expression COLON term {let s = get_value dyp.last_local_data in
						       raise_expect Entry.Type_kwd (snd ($5 bEnv.empty []))}
*/
	  
	  type_expression :
| atomic_type {$1} atom_type
| atomic_type (<= atom_type) LIN_ARROW type_expression (<=arrow_type)  {fun sg ->
									  let ty1,loc1 = $1 sg in
									  let ty2,loc2 = $3 sg in
									  let new_loc = Abstract_sig.new_loc loc1 loc2 in Abstract_sig.Linear_arrow (ty1,ty2,new_loc),new_loc} arrow_type
      
      atomic_type :
| IDENT {fun sg ->
	   let id,((pos1,pos2) as l) = $1 in
	     match Abstract_sig.is_type id sg with
	       | true -> Abstract_sig.Type_atom (id,l,[]),l
	       | false -> raise (Error.emit_parse_error (Error.Unknown_type (id,pos1,pos2)))} atom_type
| LPAREN type_expression RPAREN {fun sg -> fst ($2 sg),Abstract_sig.new_loc $1 $3} atom_type
      
      term_declaration :
| term_dec_start COLON type_expression  @{let s = get_value dyp.last_local_data in
					  let new_sig =
					    List.fold_left
					      (fun acc (id,kind,loc) -> 
						 try
						   Abstract_sig.add_entry (Abstract_sig.Term_decl (id,kind,loc,fst ($3 s))) acc
						 with
						   | Abstract_sig.Duplicate_term_definition -> 
						       let pos1,pos2= loc in
							 raise (Error.emit_parse_error (Error.Duplicated_term (id,pos1,pos2))))
					      s
					      $1 in new_sig,[Local_data (Some new_sig);Keep_grammar true]}

	  term_dec_start : 
| comma_ids {List.map (fun (id,loc) -> (id,Abstract_sig.Default,loc)) $1}
/*| PREFIX SYMBOL[sym,l] @{[sym,Abstract_sig.Prefix,l],[Add_rules [(add_prefix_rule sym,add_prefix_action sym)]]} 
| INFIX SYMBOL[sym,l] @{[sym,Abstract_sig.Infix,l],[Add_rules [(add_infix_rule sym,add_infix_action sym)]]} */
| PREFIX SYMBOL[sym,l] {[sym,Abstract_sig.Prefix,l]} 
| INFIX SYMBOL[sym,l] {[sym,Abstract_sig.Infix,l]}
| BINDER IDENT {[fst $2,Abstract_sig.Binder,snd $2]}

      term_def_start : 
| IDENT {fst $1,Abstract_sig.Default,snd $1}
/*| PREFIX SYMBOL[sym,l] @{(sym,Abstract_sig.Prefix,l),[Add_rules [(add_prefix_rule sym,add_prefix_action sym)]]}
| INFIX SYMBOL[sym,l] @{(sym,Abstract_sig.Infix,l),[Add_rules [(add_infix_rule sym,add_infix_action sym)]]}*/
| PREFIX SYMBOL[sym,l] {(sym,Abstract_sig.Prefix,l)}
| INFIX SYMBOL[sym,l] {(sym,Abstract_sig.Infix,l)}
| BINDER IDENT {fst $2,Abstract_sig.Binder,snd $2}


      term_definition :
| term_def_start EQUAL term COLON type_expression @{let id,k,l = $1 in
						    let s = get_value dyp.last_local_data in
						    let new_sig =
						      try
							let term_value,ws = $3 Env.empty [] in
							let new_sig2 = Abstract_sig.add_entry (Abstract_sig.Term_def (id,k,l,term_value,fst ($5 s))) s  in 
							  (match ws with
							    | [] -> new_sig2
							    | lst -> Abstract_sig.add_warnings ws new_sig2) with
							    | Abstract_sig.Duplicate_term_definition ->
								raise (Error.emit_parse_error (Error.Duplicated_term (id,fst l,snd l))) in new_sig,[Local_data (Some new_sig);Keep_grammar true]}
	  
	  term_alone :
| term EOI {fst ($1 Env.empty [])}	  

	  term :
/*| binder idents DOT term {fun env ws -> $1 $2 $4 env ws } binder */
| LAMBDA0  idents DOT term {
    let sg = get_value dyp.last_local_data in
      fun env ws -> multiple_abs env ws Abstract_sig.Linear $1 $2 $4 (fun x -> x)} binder
| IDENT  idents DOT term {
    let sg = get_value dyp.last_local_data in
    let binder,((p1,p2) as l) = $1 in
      fun env ws -> 
	match Abstract_sig.is_constant binder sg with
	  | true,Some Abstract_sig.Binder -> multiple_bind env ws (Abstract_sig.Const(binder,l)) (snd $1) $2 $4 (fun x -> x)
	  | _ -> raise (Error.emit_parse_error (Error.Binder_expected (binder,p1,p2)))
	  (*| _ -> raise Dyp.Giveup*) } binder 
| application(<=app) {$1} app 
| atomic_term (<=atom) SYMBOL term (<=app) {let sg = get_value dyp.last_local_data in
					     let id,((pos1,pos2) as l) = $2 in
					       match Abstract_sig.is_constant id sg with
						 | true,Some (Abstract_sig.Infix) -> 
						     (fun env ws->
							let u1,ws1 = $1 env ws in
							let u2,ws2 = $3 env ws1 in
							  (Abstract_sig.App (Abstract_sig.App(Abstract_sig.Const(id,l),u1,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) l),u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))),ws2)
						 | true,_ -> raise Dyp.Giveup
						 | _ -> raise (Error.emit_parse_error (Error.Unknown_constant (id,pos1,pos2)))}  app 
      
      atomic_term :
| IDENT {let id,l=$1 in
	 let s = get_value dyp.last_local_data in 
	 let is_constant,_ = Abstract_sig.is_constant id s in
	   fun env ws -> 
	     match Env.mem id env,is_constant with
	       | true,false -> Abstract_sig.Var (id,l),ws
	       | true,true -> Abstract_sig.Var (id,l),(Error.Variable_or_constant (id,fst l,snd l))::ws
	       | false,true -> Abstract_sig.Const (id,l),ws
	       | false,false ->raise (Error.emit_parse_error (Error.Unknown_constant (id,fst l,snd l)))} atom
| LPAREN term RPAREN {$2} atom
| SYMBOL term {let sg = get_value dyp.last_local_data in
	       let id,((pos1,pos2) as l) = $1 in
		 match Abstract_sig.is_constant id sg with
		   | true,Some (Abstract_sig.Prefix) -> 
		       (fun env ws ->
			  let u2,ws2 = $2 env ws in
			    (Abstract_sig.App(Abstract_sig.Const(id,l),u2,Abstract_sig.new_loc l (Abstract_sig.get_term_location u2))),ws2)
		   | true,_ -> raise Dyp.Giveup
		   | _ -> raise (Error.emit_parse_error (Error.Unknown_constant (id,pos1,pos2)))} atom 
      
      application :
| atomic_term(<=atom) {$1} app
| application(<=app) atomic_term(<=atom) {fun e ws ->
					      let u1,ws1 = $1 e ws in
					      let u2,ws2 = $2 e ws1 in
						(Abstract_sig.App(u1,u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))),ws2} app
      
      idents :
| {[]}
| IDENT idents {$1::$2}

      binder :
| LAMBDA0 {let sg = get_value dyp.last_local_data in fun ids t env ws -> (multiple_abs env ws Abstract_sig.Linear $1 ids t (fun x -> x))} binder
| IDENT {let sg = get_value dyp.last_local_data in let binder,((p1,p2) as l) = $1 in
	   match Abstract_sig.is_constant binder sg with
	     | true,Some Abstract_sig.Binder -> (fun ids t env ws-> (multiple_bind env ws (Abstract_sig.Const(binder,l)) (snd $1) ids t (fun x -> x)))
	     | _ -> raise Dyp.Giveup } binder


%mlitop {
  open Abstract_syntax
  module Env : Set. S with type elt = String.t
}
