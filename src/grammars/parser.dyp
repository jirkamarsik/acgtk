%mltop {
  module Env = Set.Make(String)
  module Environment = Map.Make(String)
}
{
  open Dyp
  open Abstract_syntax
  open Entry

  exception No_sig

(*  let () = dypgen_verbose :=2 *)

  type content = Abstract_sig.t Environment.t

  let local_data = None

(*  let pr s = Printf.fprintf stderr "%s\n%!" s *)

  let abs x l t = function
    | Abstract_sig.Linear -> Abstract_sig.LAbs (x,t,l)
(*    | Abstract_sig.Non_linear -> Abstract_sig.Abs (x,l,t) *)

  let rec multiple_abs e ws k_a l ids t k =
    match ids with
      | [] -> k (t e ws)
      | [a,l_a] ->
	  let new_t,new_ws = t (Env.add a e) ws in
	    k (abs a l_a new_t k_a,new_ws)
      | (a,l_a)::((_,l_b)::_ as tl) -> 
	  let new_env = Env.add a e in
	    multiple_abs new_env ws k_a l_b tl t (fun r -> k (abs a l (fst r) k_a,(snd r)))

  let bind c x l t = Abstract_sig.App (c,Abstract_sig.LAbs (x,t,l),l)

  let rec multiple_bind e ws binder l ids t k =
    match ids with
      | [] -> k (t e ws)
      | [a,l_a] ->
	  let new_t,new_ws = t (Env.add a e) ws in
	    k (bind binder a l_a new_t,new_ws)
      | (a,l_a)::((_,l_b)::_ as tl) ->
	  let new_env = Env.add a e in
	    multiple_bind new_env ws binder l_b tl t (fun r -> k (bind binder a l (fst r),(snd r)))



  let empty_output = ""

  let empty_sig = Abstract_sig.empty ""

  let set e (s,_) = Entry.set e s

  let get_value = function
    | None -> raise No_sig
    | Some s -> s

}


%token
  EOI
<Abstract_syntax.Abstract_sig.location> EQUAL
<Abstract_syntax.Abstract_sig.location> SEMICOLON
<Abstract_syntax.Abstract_sig.location> COLON
<Abstract_syntax.Abstract_sig.location> COMMA
<Abstract_syntax.Abstract_sig.location> LPAREN
<Abstract_syntax.Abstract_sig.location> RPAREN
<Abstract_syntax.Abstract_sig.location> DOT
<Abstract_syntax.Abstract_sig.location> SIG_OPEN
<Abstract_syntax.Abstract_sig.location> END_OF_DEC
<Abstract_syntax.Abstract_sig.location> TYPE
<Abstract_syntax.Abstract_sig.location> PREFIX
<Abstract_syntax.Abstract_sig.location> INFIX
<Abstract_syntax.Abstract_sig.location> BINDER
<Abstract_syntax.Abstract_sig.location> LAMBDA
<Abstract_syntax.Abstract_sig.location> LAMBDA0
<Abstract_syntax.Abstract_sig.location> ARROW
<Abstract_syntax.Abstract_sig.location> LIN_ARROW
<(string*Abstract_syntax.Abstract_sig.location)> IDENT
<(string*Abstract_syntax.Abstract_sig.location)> SYMBOL
  
%start <Abstract_syntax.Abstract_sig.t Environment.t> signatures
%start <(Env.t -> Error.warning list -> (Abstract_syntax.Abstract_sig.term * Error.warning list))> term
%start <Abstract_syntax.Abstract_sig.term> term_alone
  
%relation atom<app<binder atom_type<arrow_type

%local_data_type <(Abstract_syntax.Abstract_sig.t option)>
  
%%
  
  signatures :
| EOI {Environment.empty}
| signature signatures {Entry.set Entry.Signatures empty_output ; Environment.add (Abstract_sig.name $1) $1 $2}

      signature : 
| SIG_OPEN ident EQUAL sig_entries END_OF_DEC {set Entry.Signature $2 ; $4}
| SIG_OPEN ident EQUAL sig_entries SEMICOLON END_OF_DEC {set Entry.Signature $2 ; $4}
      
      ident :
| IDENT @{$1,[Local_data (Some (Abstract_sig.empty (fst $1)))]}

	  sig_entries :
| sig_entry @{Entry.set Entry.Sig_entries "Entry Stop" ; $1,[Local_data (Some $1)]}
| sig_entry SEMICOLON sig_entries @{Entry.set Entry.Sig_entries "Entry Stop" ; $3,[Local_data (Some $3)]}

      sig_entry :
| type_declaration @{Entry.set Entry.Sig_entry "type declaration" ;$1,[Local_data dyp.last_local_data]}
| type_definition @{Entry.set Entry.Sig_entry "type definition" ; $1,[Local_data dyp.last_local_data]}
| term_declaration @{Entry.set Entry.Sig_entry "term declaration" ; $1,[Local_data dyp.last_local_data]}
| term_definition @{Entry.set Entry.Sig_entry "term definition" ; $1,[Local_data dyp.last_local_data]}

      
      type_declaration :
| comma_ids COLON TYPE @{Entry.set Entry.Type_decl "entered comma ids";
			let s = get_value dyp.last_local_data in
			let new_sig =
			  List.fold_left
			    (fun acc id ->
			       try
				 Abstract_sig.add_entry (Abstract_sig.Type_decl (fst id,snd id,Abstract_sig.K [])) acc
			       with
				 | Abstract_sig.Duplicate_type_definition -> 
				     let pos1,pos2= snd id in
				       raise (Error.emit_parse_error (Error.Duplicated_type (fst id,pos1,pos2))))
			    s
			    $1 in
			  new_sig,[Local_data (Some new_sig)]}

	  comma_ids :
| IDENT {set Entry.Comma_ids $1; [$1]}
| IDENT COMMA comma_ids {set Entry.Comma_ids $1 ; $1::$3}

      type_definition :
| IDENT EQUAL type_expression COLON TYPE @{set Entry.Type_def $1 ;
					   let s = get_value dyp.last_local_data in
					   let new_sig =
					     try
					       Abstract_sig.add_entry (Abstract_sig.Type_def (fst $1,snd $1,fst ($3 s))) s
					     with
					       | Abstract_sig.Duplicate_type_definition -> 
						   let pos1,pos2= snd $1 in
						     raise (Error.emit_parse_error (Error.Duplicated_type (fst $1,pos1,pos2))) in 
					     new_sig,[Local_data (Some new_sig)]}
	  
	  type_expression :
| atomic_type {Entry.set Entry.Type_exp "" ; $1} atom_type
| atomic_type (<= atom_type) LIN_ARROW type_expression (<=arrow_type)  {Entry.set Entry.Type_exp "->" ; 
									fun sg ->
									  let ty1,loc1 = $1 sg in
									  let ty2,loc2 = $3 sg in
									  let new_loc = Abstract_sig.new_loc loc1 loc2 in Abstract_sig.Linear_arrow (ty1,ty2,new_loc),new_loc} arrow_type
      
      atomic_type :
| IDENT {set Entry.Atomic_type $1 ; fun sg ->
	   let id,((pos1,pos2) as l) = $1 in
	     match Abstract_sig.is_type id sg with
	       | true -> Abstract_sig.Type_atom (id,l,[]),l
	       | false -> raise (Error.emit_parse_error (Error.Unknown_type (id,pos1,pos2)))} atom_type
| LPAREN type_expression RPAREN {Entry.set Entry.Atomic_type "()"; fun sg -> fst ($2 sg),Abstract_sig.new_loc $1 $3} atom_type
      
      term_declaration :
| term_dec_start COLON type_expression  @{Entry.set Entry.Term_decl ":" ; let s = get_value dyp.last_local_data in
					  let new_sig =
					    List.fold_left
					      (fun acc (id,kind,loc) -> 
						 try
						   Abstract_sig.add_entry (Abstract_sig.Term_decl (id,kind,loc,fst ($3 s))) acc
						 with
						   | Abstract_sig.Duplicate_term_definition -> 
						       let pos1,pos2= loc in
							 raise (Error.emit_parse_error (Error.Duplicated_term (id,pos1,pos2))))
					      s
					      $1 in new_sig,[Local_data (Some new_sig)]}

	  term_dec_start : 
| comma_ids {Entry.set Entry.Term_dec_start "comma_ids" ; List.map (fun (id,loc) -> (id,Abstract_sig.Default,loc)) $1}
| PREFIX SYMBOL {Entry.set Entry.Term_dec_start "$2" ; [fst $2,Abstract_sig.Prefix,snd $2]} 
| INFIX SYMBOL {Entry.set Entry.Term_dec_start  "$2"; [fst $2,Abstract_sig.Infix,snd $2]}
| BINDER IDENT {Entry.set Entry.Term_dec_start  "$2"; [fst $2,Abstract_sig.Binder,snd $2]}

      term_def_start : 
| IDENT {set Entry.Term_def_start $1 ; fst $1,Abstract_sig.Default,snd $1}
| PREFIX SYMBOL {Entry.set Entry.Term_def_start  "$2" ; fst $2,Abstract_sig.Prefix,snd $2}
| INFIX SYMBOL {Entry.set Entry.Term_def_start  "$2" ; fst $2,Abstract_sig.Infix,snd $2}
| BINDER IDENT {Entry.set Entry.Term_def_start  "$2"; fst $2,Abstract_sig.Binder,snd $2}


      term_definition :
| term_def_start EQUAL term COLON type_expression @{Entry.set Entry.Term_def empty_output; 
						    let id,k,l = $1 in
						    let s = get_value dyp.last_local_data in
						    let new_sig =
						      try
							let term_value,ws = $3 Env.empty [] in
							let new_sig2 = Abstract_sig.add_entry (Abstract_sig.Term_def (id,k,l,term_value,fst ($5 s))) s  in 
							  (match ws with
							    | [] -> new_sig2
							    | lst -> Abstract_sig.add_warnings ws new_sig2) with
							    | Abstract_sig.Duplicate_term_definition ->
								raise (Error.emit_parse_error (Error.Duplicated_term (id,fst l,snd l))) in new_sig,[Local_data (Some new_sig)]}
	  
	  term_alone :
| term EOI {fst ($1 Env.empty [])}	  

	  term :
| binder idents DOT term {Entry.set Entry.Term "starting with a binder" ; fun env ws -> $1 $2 $4 env ws } binder 
| application(<=app) {Entry.set Entry.Term "performing application"; $1} app 
| atomic_term (<=atom) SYMBOL term (<=app) { set Entry.Term $2 ;
					     let sg = get_value dyp.last_local_data in
					     let id,((pos1,pos2) as l) = $2 in
					       match Abstract_sig.is_constant id sg with
						 | true,Some (Abstract_sig.Infix) -> 
						     (fun env ws->
							let u1,ws1 = $1 env ws in
							let u2,ws2 = $3 env ws1 in
							  (Abstract_sig.App (Abstract_sig.App(Abstract_sig.Const(id,l),u1,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) l),u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))),ws2)
						 | true,_ -> raise Dyp.Giveup
						 | _ -> raise (Error.emit_parse_error (Error.Unknown_constant (id,pos1,pos2)))}  app 
      
      atomic_term :
| IDENT {set Entry.Atomic_term $1; 
	 let id,l=$1 in
	 let s = get_value dyp.last_local_data in 
	 let is_constant,_ = Abstract_sig.is_constant id s in
	   fun env ws -> 
	     match Env.mem id env,is_constant with
	       | true,false -> Abstract_sig.Var (id,l),ws
	       | true,true -> Abstract_sig.Var (id,l),(Error.Variable_or_constant (id,fst l,snd l))::ws
	       | false,true -> Abstract_sig.Const (id,l),ws
	       | false,false ->raise (Error.emit_parse_error (Error.Unknown_constant (id,fst l,snd l)))} atom
| LPAREN term RPAREN {Entry.set Entry.Atomic_term "()" ; $2} atom
| SYMBOL term {set Entry.Atomic_term (Printf.sprintf "Prefix Symbol: %s" (fst $1),snd $1) ; 
	       let sg = get_value dyp.last_local_data in
	       let id,((pos1,pos2) as l) = $1 in
		 match Abstract_sig.is_constant id sg with
		   | true,Some (Abstract_sig.Prefix) -> 
		       (fun env ws ->
			  let u2,ws2 = $2 env ws in
			    (Abstract_sig.App(Abstract_sig.Const(id,l),u2,Abstract_sig.new_loc l (Abstract_sig.get_term_location u2))),ws2)
		   | true,_ -> raise Dyp.Giveup
		   | _ -> raise (Error.emit_parse_error (Error.Unknown_constant (id,pos1,pos2)))} atom 
      
      application :
| atomic_term(<=atom) {Entry.set Entry.Application "atom" ; $1} app
| application(<=app) atomic_term(<=atom) {Entry.set Entry.Application "actual application" ; 
					    fun e ws ->
					      let u1,ws1 = $1 e ws in
					      let u2,ws2 = $2 e ws1 in
						(Abstract_sig.App(u1,u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))),ws2} app
      
      idents :
| {[]}
| IDENT idents {set Entry.Idents $1 ; $1::$2}

      binder :
| LAMBDA0 {Entry.set Entry.Binder "lambda" ; let sg = get_value dyp.last_local_data in fun ids t env ws -> (multiple_abs env ws Abstract_sig.Linear $1 ids t (fun x -> x))}
| IDENT {set Entry.Binder $1 ; let sg = get_value dyp.last_local_data in let binder,((p1,p2) as l) = $1 in
	   match Abstract_sig.is_constant binder sg with
	     | true,Some Abstract_sig.Binder -> (fun ids t env ws-> (multiple_bind env ws (Abstract_sig.Const(binder,l)) (snd $1) ids t (fun x -> x)))
	     | _ -> raise Dyp.Giveup
(*	     | true,_ -> raise Dyp.Giveup
	     | _  -> raise (Error.emit_parse_error (Error.Binder_expected (binder,p1,p2))) *)} 
    /*| LAMBDA {Abstract_sig.Non_linear} */ 


%mlitop {
  open Abstract_syntax
  module Env : Set. S with type elt = String.t
  module Environment : Map.S with type key = String.t
    
  type content = Abstract_sig.t Environment.t
}
