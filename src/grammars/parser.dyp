{
  open Dyp
  open Abstract_syntax
  open Entry

(*  let () = dypgen_verbose :=2 *)

  module Env = Set.Make(String)

  module Symbols = Map.Make(String)

  type symbols = Abstract_sig.term_kind Symbols.t


  let parse_error e = raise (Error.Error (Error.Parse_error e))


  let add_symbol (s,(l1,l2)) kind table =
      match Symbols.mem s table with
	| true -> parse_error ((Error.Duplicated_type (s,l1,l2)))
	| false -> Symbols.add s kind table
	    
  let add_infix s table = add_symbol s Abstract_sig.Infix table	    
  let add_prefix s table = add_symbol s Abstract_sig.Prefix table
  let add_default s table = add_symbol s Abstract_sig.Default table
  let add_binder s table = add_symbol s Abstract_sig.Binder table

  let is_infix s table =
    try
      Symbols.find s table = Abstract_sig.Infix
    with
      | Not_found -> false

  let is_prefix s table =
      try
	Symbols.find s table = Abstract_sig.Prefix
      with
	| Not_found -> false

  let empty_sym = Symbols.empty

  let global_data = empty_sym

(*  let pr s = Printf.fprintf stderr "%s\n%!" s *)

  let abs x l t = function
    | Abstract_sig.Linear -> Abstract_sig.LAbs (x,t,l)
(*    | Abstract_sig.Non_linear -> Abstract_sig.Abs (x,l,t) *)

  let rec multiple_abs e k_a l ids t k =
    match ids with
      | [] -> k (t e)
      | [a,l_a] ->
	    k (abs a l_a (t (Env.add a e)) k_a)
      | (a,l_a)::((_,l_b)::_ as tl) -> 
	  let new_env = Env.add a e in
	    multiple_abs new_env k_a l_b tl t (fun r -> k (abs a l r k_a))

  let bind c x l t = Abstract_sig.App (c,Abstract_sig.LAbs (x,t,l),l)

  let rec multiple_bind e binder l ids t k =
    match ids with
      | [] -> k (t e)
      | [a,l_a] ->
	    k (bind binder a l_a (t (Env.add a e)))
      | (a,l_a)::((_,l_b)::_ as tl) ->
	  let new_env = Env.add a e in
	    multiple_bind new_env binder l_b tl t (fun r -> k (bind binder a l r))



  let empty_output = ""

  let empty_sig = Abstract_sig.empty ""

  let set e (s,_) = Entry.set e s
}


%token
  EOI
<Abstract_syntax.Abstract_sig.location> EQUAL
<Abstract_syntax.Abstract_sig.location> SEMICOLON
<Abstract_syntax.Abstract_sig.location> COLON
<Abstract_syntax.Abstract_sig.location> COMMA
<Abstract_syntax.Abstract_sig.location> LPAREN
<Abstract_syntax.Abstract_sig.location> RPAREN
<Abstract_syntax.Abstract_sig.location> DOT
<Abstract_syntax.Abstract_sig.location> SIG_OPEN
<Abstract_syntax.Abstract_sig.location> END_OF_DEC
<Abstract_syntax.Abstract_sig.location> TYPE
<Abstract_syntax.Abstract_sig.location> PREFIX
<Abstract_syntax.Abstract_sig.location> INFIX
<Abstract_syntax.Abstract_sig.location> BINDER
<Abstract_syntax.Abstract_sig.location> LAMBDA
<Abstract_syntax.Abstract_sig.location> LAMBDA0
<Abstract_syntax.Abstract_sig.location> ARROW
<Abstract_syntax.Abstract_sig.location> LIN_ARROW
<(string*Abstract_syntax.Abstract_sig.location)> IDENT
<(string*Abstract_syntax.Abstract_sig.location)> SYMBOL
  
%start <Abstract_syntax.Abstract_sig.t list> signatures
  
%relation atom<app<binder atom_type<arrow_type

%global_data_type <Abstract_sig.term_kind Symbols.t>
  
%%
  
  signatures :
| EOI {[]}
| signature signatures {Entry.set Entry.Signatures empty_output ; $1::$2}

      signature : 
| SIG_OPEN IDENT EQUAL sig_entries END_OF_DEC {set Entry.Signature $2 ; $4 (Abstract_sig.empty (fst $2))}
| SIG_OPEN IDENT EQUAL sig_entries SEMICOLON END_OF_DEC {set Entry.Signature $2 ; $4 (Abstract_sig.empty (fst $2))}
      
      sig_entries :
| sig_entry {Entry.set Entry.Sig_entries "Entry Stop" ; fun s -> $1 s}
| sig_entry SEMICOLON sig_entries {Entry.set Entry.Sig_entries "Entry Stop" ; fun s -> $3 ($1 s)}
      
      sig_entry :
| type_declaration {Entry.set Entry.Sig_entry "type declaration" ; $1}
| type_definition {Entry.set Entry.Sig_entry "type definition" ; $1}
| term_declaration {Entry.set Entry.Sig_entry "term declaration" ; $1}
| term_definition {Entry.set Entry.Sig_entry "term definition" ; $1}
      
      type_declaration :
| comma_ids COLON TYPE {Entry.set Entry.Type_decl "entered comma ids"; fun s -> 
			  List.fold_left
			    (fun acc id ->
			       try
				 Abstract_sig.add_entry (Abstract_sig.Type_decl (fst id,snd id,Abstract_sig.K [])) acc
			       with
				 | Abstract_sig.Duplicate_type_definition -> 
				     let pos1,pos2= snd id in
				       parse_error (Error.Duplicated_type (fst id,pos1,pos2)))
			    s
			    $1}

	  comma_ids :
| IDENT {set Entry.Comma_ids $1; [$1]}
| IDENT COMMA comma_ids {set Entry.Comma_ids $1 ; $1::$3}

      type_definition :
| IDENT EQUAL type_expression COLON TYPE {set Entry.Type_def $1 ; fun s ->
					    try
					      Abstract_sig.add_entry (Abstract_sig.Type_def (fst $1,snd $1,fst ($3 s))) s
					    with
					      | Abstract_sig.Duplicate_type_definition -> 
						 let pos1,pos2= snd $1 in
						   parse_error (Error.Duplicated_type (fst $1,pos1,pos2))}
	  
	  type_expression :
| atomic_type {Entry.set Entry.Type_exp "" ; $1} atom_type
| atomic_type (<= atom_type) LIN_ARROW type_expression (<=arrow_type)  {Entry.set Entry.Type_exp "->" ; 
									fun sg ->
									  let ty1,loc1 = $1 sg in
									  let ty2,loc2 = $3 sg in
									  let new_loc = Abstract_sig.new_loc loc1 loc2 in Abstract_sig.Linear_arrow (ty1,ty2,new_loc),new_loc} arrow_type
      
      atomic_type :
| IDENT {set Entry.Atomic_type $1 ; fun sg ->
	   let id,((pos1,pos2) as l) = $1 in
	     match Abstract_sig.is_type id sg with
	       | true -> Abstract_sig.Type_atom (id,l,[]),l
	       | false -> parse_error (Error.Unknown_type (id,pos1,pos2))} atom_type
| LPAREN type_expression RPAREN {Entry.set Entry.Atomic_type "()"; fun sg -> fst ($2 sg),Abstract_sig.new_loc $1 $3} atom_type
      
      term_declaration :
| term_dec_start COLON type_expression  {Entry.set Entry.Term_decl ":" ; fun s ->
					   List.fold_left
					     (fun acc (id,kind,loc) -> 
						try
						  Abstract_sig.add_entry (Abstract_sig.Term_decl (id,kind,loc,fst ($3 s))) acc
						with
						  | Abstract_sig.Duplicate_term_definition -> 
						      let pos1,pos2= loc in
							parse_error (Error.Duplicated_term (id,pos1,pos2)))
					     s
					     $1}

	  term_dec_start : 
| comma_ids {Entry.set Entry.Term_dec_start "comma_ids" ; List.map (fun (id,loc) -> (id,Abstract_sig.Default,loc)) $1}
| PREFIX SYMBOL @{Entry.set Entry.Term_dec_start "$2" ; [fst $2,Abstract_sig.Prefix,snd $2],[Global_data (add_prefix $2 dyp.global_data)]}
| INFIX SYMBOL @{Entry.set Entry.Term_dec_start  "$2"; [fst $2,Abstract_sig.Infix,snd $2],[Global_data (add_infix $2 dyp.global_data)]}
| BINDER IDENT {Entry.set Entry.Term_dec_start  "$2"; [fst $2,Abstract_sig.Binder,snd $2]}

      term_def_start : 
| IDENT {set Entry.Term_def_start $1 ; fst $1,Abstract_sig.Default,snd $1}
| PREFIX SYMBOL @{Entry.set Entry.Term_def_start  "$2" ; (fst $2,Abstract_sig.Prefix,snd $2),[Global_data (add_prefix $2 dyp.global_data)]}
| INFIX SYMBOL @{Entry.set Entry.Term_def_start  "$2" ; (fst $2,Abstract_sig.Infix,snd $2),[Global_data (add_infix $2 dyp.global_data)]}
| BINDER IDENT {Entry.set Entry.Term_def_start  "$2"; fst $2,Abstract_sig.Binder,snd $2}

      term_definition :
| term_def_start EQUAL term COLON type_expression {Entry.set Entry.Term_def empty_output; 
						   let id,k,l = $1 in
						     fun s -> 
						       try
							 Abstract_sig.add_entry (Abstract_sig.Term_def (id,k,l,$3 s Env.empty,fst ($5 s))) s with
							   | Abstract_sig.Duplicate_term_definition ->
								 parse_error (Error.Duplicated_term (id,fst l,snd l))}
	  
	  
	  term :
| binder idents DOT term {Entry.set Entry.Term "starting with a binder" ; fun s env -> ($1 s) $2 $4 env} binder
| application(<=app) {Entry.set Entry.Term "performing application"; $1} app
| atomic_term (<=atom) SYMBOL term (<=app) { set Entry.Term $2 ;
					     let s,(l1,l2)=$2 in
					     if not (is_infix s dyp.global_data) then
					       if not (is_prefix s dyp.global_data) then
						 parse_error (Error.Unknown_constant (s,l1,l2))
					       else
						 raise Dyp.Giveup
					     else
					       fun sg env -> 
						 let id,((pos1,pos2) as l) = $2 in
						   match Abstract_sig.is_constant id sg with
						     | true,Some (Abstract_sig.Infix) -> 
							 let u1 = $1 sg env in
							 let u2 = $3 sg env in
							   Abstract_sig.App (Abstract_sig.App(Abstract_sig.Const(id,l),u1,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) l),u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))
						     | _ -> raise Dyp.Giveup}  app 
      
      atomic_term :
| IDENT {set Entry.Atomic_term $1; fun s -> let id,l=$1 in
	   fun env -> 
	     match Env.mem id env with
	       | true -> Abstract_sig.Var (id,l)
	       | false -> 
		   (match Abstract_sig.is_constant id s with
		      | true,_ -> Abstract_sig.Const (id,l)
		      | false,_ -> parse_error (Error.Unknown_constant (id,fst l,snd l)))} atom
| LPAREN term RPAREN {Entry.set Entry.Atomic_term "()" ; $2} atom
| SYMBOL term {set Entry.Atomic_term (Printf.sprintf "Prefix Symbol: %s" (fst $1),snd $1) ; 
	       let s,(l1,l2)=$1 in
		 if not (is_prefix s dyp.global_data) then
		   if not (is_infix s dyp.global_data) then
		     parse_error (Error.Unknown_constant (s,l1,l2))
		   else
		     raise Dyp.Giveup
		 else
		   fun sg env -> 
		     let id,((pos1,pos2) as l) = $1 in
		       match Abstract_sig.is_constant id sg with
			 | true,Some (Abstract_sig.Prefix) -> 
			     let u2 = $2 sg env in
			       Abstract_sig.App(Abstract_sig.Const(id,l),u2,Abstract_sig.new_loc l (Abstract_sig.get_term_location u2))
			 | _ -> raise Dyp.Giveup} atom
      
      application :
| atomic_term(<=atom) {Entry.set Entry.Application "atom" ; $1} app
| application(<=app) atomic_term(<=atom) {Entry.set Entry.Application "actual application" ; fun s e ->
					    let u1 = $1 s e in
					    let u2 = $2 s e in
					      Abstract_sig.App(u1,u2,Abstract_sig.new_loc (Abstract_sig.get_term_location u1) (Abstract_sig.get_term_location u2))} app

      idents :
| {[]}
| IDENT idents {set Entry.Idents $1 ; $1::$2}

      binder :
| LAMBDA0 {Entry.set Entry.Binder "lambda" ; fun sg ids t env -> multiple_abs env Abstract_sig.Linear $1 ids (t sg) (fun x -> x)}
| IDENT {set Entry.Binder $1 ; fun sg -> let binder,((p1,p2) as l) = $1 in
	   match Abstract_sig.is_constant binder sg with
	     | true,Some Abstract_sig.Binder -> fun ids t env -> multiple_bind env (Abstract_sig.Const(binder,l)) (snd $1) ids (t sg) (fun x -> x)
	       | _  -> parse_error (Error.Binder_expected (binder,p1,p2))}
    /*| LAMBDA {Abstract_sig.Non_linear} */


%mlitop {
  open Abstract_syntax
  module Symbols : Map.S with type key = String.t
    
  type symbols = Abstract_sig.term_kind Symbols.t
}
